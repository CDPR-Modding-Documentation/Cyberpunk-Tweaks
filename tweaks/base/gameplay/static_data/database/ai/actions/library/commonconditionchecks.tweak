package Condition
using RTDB, MovementActions, CombatDecorator

SquadClosestToStimTarget : AISquadClosestToTargetCheck
{
	target = "AIActionTarget.StimTarget";
}

SquadClosestToStimSource : AISquadClosestToTargetCheck
{
	target = "AIActionTarget.StimSource";
}

SquadClosestToCombatTarget : AISquadClosestToTargetCheck
{
	target = "AIActionTarget.CombatTarget";
}

SquadFurthestToCombatTarget : AISquadFurthestToTargetCheck
{
	target = "AIActionTarget.CombatTarget";
}

SquadOwnerCanRequestAttack : AISquadFilterByAICondition
{
	condition = 
	{
		condition = 
		{
			AND = 
			[
				"Condition.NotMeleeStatesExceptTauntConditions", {
					OR = 
					[
						"Condition.NotTargetIsPlayer", {
							AND = 
							[
								"Condition.TargetIsPlayer", "Condition.NotIsInWorkspot"
							];
						} : AIActionAND
					];
				} : AIActionOR
			];
		} : AIActionAND;
	};
}

SquadOwnerMeleeTicketExpiration : AISquadFilterByAICondition
{
	condition = 
	{
		condition = 
		{
			AND = 
			[
				"Condition.MeleeTicketExpiration"
			];
		} : AIActionAND;
	};
}

NotIsAndroidTicketCondition : IsAndroidTicketCondition
{
	invert = true;
}

IsAndroidTicketCondition : AISquadFilterByAICondition
{
	condition = 
	{
		condition = 
		{
			AND = 
			[
				"Condition.Android"
			];
		} : AIActionAND;
	};
}

SquadOwnerTargetHasRangedWeapon : AISquadFilterByAICondition
{
	condition = 
	{
		condition = 
		{
			AND = 
			[
				"Condition.TargetHasRangedWeapon"
			];
		} : AIActionAND;
	};
}

SquadContainsSelfCheck : AISquadContainsSelfCheck
{
}

SquadAvoidLastFilter : AISquadAvoidLastFilter
{
}

NotSimpleCombatCommandCondition : AIActionOR
{
	OR = 
	[
		"Condition.AICommand", "Condition.NotAIThrowGrenadeCommand", "Condition.NotAIUseCoverCommand", "Condition.NotAIMeleeAttackCommand"
	];
}

CatchUpAccuracyCondition : AIActionOR
{
	OR = 
	[
		"Condition.NotMinAccuracyValue0dot66", {
			AND = 
			[
				{
					OR = 
					[
						"Condition.AbilityIsReckless", "Condition.AbilityIsAggressive"
					];
				} : AIActionOR, 
				"Condition.TargetIsPlayer", "Condition.NotMinAccuracyValue0dot95"
			];
		} : AIActionAND
	];
}

NotCatchUpCondition : CatchUpCondition
{
	invert = true;
}

CatchUpCondition : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanCatchUp", "Condition.TargetAbove3m", "Condition.NotAbilityIsCautious", "Condition.TicketCheckCatchUp", "Condition.MovePolicyCooldown", "Condition.PathMovePolicyLongCooldown", "Condition.PauseByDynamicCollisionCooldown", "Condition.InitialCatchUpCooldown", "Condition.TargetInRestrictedMovementArea", "Condition.NotTargetInSafeZone", "Condition.NotMinAccuracyValue0dot66", "Condition.NotTargetIsVisible", "Condition.NotTargetInvalidExpectation", "Condition.NotAIUseWorkspotCommand", "Condition.NotAIHoldPositionCommand", "Condition.NotIsNPCBlinded"
	];
}

NotCatchUpFromCoverCondition : CatchUpFromCoverCondition
{
	invert = true;
}

CatchUpFromCoverCondition : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanCatchUp", "Condition.NotAbilityIsCautious", "Condition.TicketCheckCatchUp", "Condition.MovePolicyCooldown", "Condition.PathMovePolicyLongCooldown", "Condition.PauseByDynamicCollisionCooldown", "Condition.InitialCatchUpCooldown", "Condition.TargetInRestrictedMovementArea", "Condition.NotTargetInSafeZone", "Condition.NotMinAccuracyValue0dot33", "Condition.NotTargetIsVisible", "Condition.NotTargetInvalidExpectation", "Condition.NotAIUseWorkspotCommand", "Condition.NotAIHoldPositionCommand", "Condition.NotIsNPCBlinded"
	];
}

NotWounded : Wounded
{
	invert = true;
}

Wounded : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTagWounded"
	];
}

NotWoundedFlesh : WoundedFlesh
{
	invert = true;
}

WoundedFlesh : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTagCrippled"
	];
}

WoundedCyber : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTagDismembered"
	];
}

NotWoundedArms : AIActionAND
{
	AND = 
	[
		"Condition.NotStatusEffectTagCrippledArm", "Condition.NotStatusEffectTagDismemberedArm"
	];
}

WoundedArms : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTagCrippledArm", "Condition.StatusEffectTagDismemberedArm"
	];
}

WoundedArmLeft : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTagLeftArm"
	];
}

WoundedArmRight : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTagRightArm"
	];
}

NotWoundedLegs : WoundedLegs
{
	invert = true;
}

WoundedLegs : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTagCrippledLeg"
	];
}

NotCompanionAway : CompanionAway
{
	invert = true;
}

CompanionAway : AIActionAND
{
	AND = 
	[
		"Condition.IsFollower", "Condition.FollowerAbove17m"
	];
}

NotCompanionNearby : CompanionNearby
{
	invert = true;
}

CompanionNearby : AIActionAND
{
	AND = 
	[
		"Condition.IsFollower", "Condition.FollowerBelow17m"
	];
}

NotCanReanimateSquadmate : CanReanimateSquadmate
{
	invert = true;
}

CanReanimateSquadmate : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanResurrectAllies", "Condition.NearestDefeatedSquadmate"
	];
}

DestinationReached : AIActionAND
{
	AND = 
	[
		"Condition.DistanceToDestination0", "Condition.NotIsMoving", {
			OR = 
			[
				"Condition.DestinationCalculated", "Condition.MovementIsEvaluated"
			];
		} : AIActionOR
	];
}

ReachedTargetBeliefPosition : AIActionAND
{
	AND = 
	[
		"Condition.MovementIsEvaluated", "Condition.TargetBelow5m"
	];
}

SimpleCoverActivationCondition : AIActionAND
{
	AND = 
	[
		{
			OR = 
			[
				"Condition.CurrentCoverToTargetAbove4mPrediction", "Condition.TargetStatusEffectOpticalCamo"
			];
		} : AIActionOR, 
		"Condition.AbilityCanUseCovers", "Condition.CoverIsProtectingHorizontallyAgainstTarget", "Condition.NotDesiredCoverChanged", "Condition.NotGracefulCombatInterruption", "Condition.NotTicketCatchUpToMeleePlayerOnHard", "Condition.NotTicketCatchUpToMeleePlayerOnVeryHard"
	];
}

CoverActivationCondition : AIActionAND
{
	AND = 
	[
		{
			OR = 
			[
				{
					AND = 
					[
						"Condition.NotAbilityHasSandevistan", "Condition.CurrentCoverToTargetAbove4mPrediction"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.AbilityHasSandevistan", "Condition.CurrentCoverToTargetAbove9mPrediction"
					];
				} : AIActionAND, 
				"Condition.TargetStatusEffectOpticalCamo"
			];
		} : AIActionOR, 
		"Condition.AbilityCanUseCovers", "Condition.NotCatchUpFromCoverCondition", "Condition.CoverIsProtectingHorizontallyAgainstTarget", "Condition.NotDesiredCoverChanged", "Condition.NotAIMoveCommand", "Condition.NotAIUseWorkspotCommand", "Condition.NotGracefulCombatInterruption", "Condition.NotCompanionAway", "Condition.NotTicketCatchUpToMeleePlayerOnHard", "Condition.NotTicketCatchUpToMeleePlayerOnVeryHard"
	];
}

SimpleCoverDeactivationCondition : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.CurrentCoverToTargetBelow4mPrediction", "Condition.NotTargetStatusEffectOpticalCamo"
			];
		} : AIActionAND, 
		"Condition.NotCoverIsProtectingHorizontallyAgainstTarget", "Condition.DesiredCoverChanged", "Condition.GracefulCombatInterruption", "Condition.TicketCatchUpToMeleePlayerOnHard", "Condition.TicketCatchUpToMeleePlayerOnVeryHard"
	];
}

CoverDeactivationCondition : AIActionAND
{
	AND = 
	[
		{
			OR = 
			[
				{
					AND = 
					[
						{
							OR = 
							[
								{
									AND = 
									[
										"Condition.NotAbilityHasSandevistan", "Condition.CurrentCoverToTargetBelow4mPrediction"
									];
								} : AIActionAND, 
								{
									AND = 
									[
										"Condition.AbilityHasSandevistan", "Condition.CurrentCoverToTargetBelow9mPrediction"
									];
								} : AIActionAND
							];
						} : AIActionOR, 
						"Condition.NotTargetStatusEffectOpticalCamo"
					];
				} : AIActionAND, 
				"Condition.NotCoverIsProtectingHorizontallyAgainstTarget", "Condition.CatchUpFromCoverCondition", "Condition.DesiredCoverChanged", "Condition.AIMoveCommand", "Condition.AIUseWorkspotCommand", "Condition.GracefulCombatInterruption", "Condition.CompanionAway", "Condition.TicketCatchUpToMeleePlayerOnHard", "Condition.TicketCatchUpToMeleePlayerOnVeryHard"
			];
		} : AIActionOR, 
		"Condition.NotTicketGrenadeThrow"
	];
}

CommandCoverDeactivationCondition : AIActionAND
{
	AND = 
	[
		{
			OR = 
			[
				{
					AND = 
					[
						"Condition.CurrentCoverToTargetBelow4mPrediction", "Condition.NotTargetStatusEffectOpticalCamo"
					];
				} : AIActionAND, 
				"Condition.NotCoverIsProtectingHorizontallyAgainstTarget", "Condition.DesiredCoverChanged", "Condition.AIMoveCommand", "Condition.AIUseWorkspotCommand", "Condition.GracefulCombatInterruption"
			];
		} : AIActionOR, 
		"Condition.NotTicketGrenadeThrow"
	];
}

SimpleCoverShootDeactivationCondition : AIActionOR
{
	OR = 
	[
		"Condition.RightArmLookAtOff", "Condition.AmmoCount0", "Condition.HitCount3Timeout3", "Condition.CombatTargetChanged", "Condition.SimpleCoverDeactivationCondition"
	];
}

CoverShootDeactivationCondition : AIActionOR
{
	OR = 
	[
		"Condition.RightArmLookAtOff", "Condition.AmmoCount0", "Condition.HitCount3Timeout3", "Condition.CombatTargetChanged", "Condition.CoverDeactivationCondition"
	];
}

CommandCoverShootDeactivationCondition : AIActionOR
{
	OR = 
	[
		"Condition.RightArmLookAtOff", "Condition.AmmoCount0", "Condition.HitCount3Timeout3", "Condition.CombatTargetChanged", "Condition.CommandCoverDeactivationCondition"
	];
}

MeleeTicketConditions : AIActionAND
{
	AND = 
	[
		"Condition.TargetIsVisible", "Condition.CalculatePathToTarget", "Condition.TargetInRestrictedMovementArea", "Condition.NotTargetInSafeZone", "Condition.HasMeleeWeapon", "Condition.NotMeleeStatesExceptAttackConditions", "Condition.NotTicketEquip", "Condition.NotTicketSync", "Condition.NotIsUsingOffMeshLink", "Condition.NotTargetInVehicle", "Condition.NotStatusEffectLocomotionMalfunctionLevel3", "Condition.NotStatusEffectLocomotionMalfunctionLevel4", {
			invert = true;
			AND = 
			[
				{
					OR = 
					[
						{
							AND = 
							[
								"Condition.TargetHasRangedWeapon", "Condition.AbilityIsDefensive"
							];
						} : AIActionAND, 
						"Condition.AbilityIsCautious"
					];
				} : AIActionOR, 
				{
					OR = 
					[
						"Condition.TargetAbove12m", {
							AND = 
							[
								"Condition.TargetAbove7m", "Condition.NotIsInCameraFrustrum"
							];
						} : AIActionAND, 
						{
							AND = 
							[
								"Condition.TargetAbove9m", "Condition.AbilityIsCautious"
							];
						} : AIActionAND
					];
				} : AIActionOR
			];
		} : AIActionAND, 
		{
			OR = 
			[
				"Condition.NotHitTimeout0dot7MinSeverity2", "Condition.StatusEffectBerserkNPCBuff", "Condition.PreviousAttackNameBlockDodge", "Condition.TargetHasRangedWeapon"
			];
		} : AIActionOR, 
		{
			OR = 
			[
				"Condition.TicketBlock", "Condition.TicketCheckMeleeApproach", "Condition.TargetBelow5m"
			];
		} : AIActionOR, 
		{
			OR = 
			[
				"Condition.TargetAbove3m", {
					AND = 
					[
						"Condition.TargetBelow3m", "Condition.CalculatePathStraightFullCheckToTarget"
					];
				} : AIActionAND
			];
		} : AIActionOR, 
		{
			OR = 
			[
				"Condition.NotIsNPCUnderLocomotionMalfunctionQuickhack", "Condition.TargetBelow2m"
			];
		} : AIActionOR, 
		{
			OR = 
			[
				"Condition.DefensiveMeleeAttackOpportunity", "Condition.NotBlockStateCooldown", "Condition.NotAbilityCanBlock", "Condition.TargetHasRangedWeapon"
			];
		} : AIActionOR
	];
}

DefensiveMeleeAttackOpportunity : AIActionAND
{
	AND = 
	[
		{
			OR = 
			[
				"Condition.MeleeDefenseCooldown", "Condition.TargetStaminaBelow35Perc", "Condition.PreviousAttackNameBlockDodge", "Condition.TargetInStatesBlock", "Condition.TargetPOVAbove60deg"
			];
		} : AIActionOR
	];
}

NotDefensiveMeleeAttackOpportunity : AIActionAND
{
	AND = 
	[
		"Condition.NotMeleeDefenseCooldown", "Condition.TargetStaminaAbove35Perc", "Condition.NotPreviousAttackNameBlockDodge", "Condition.NotTargetInStatesBlock", "Condition.TargetPOVBelow50deg"
	];
}

HackSelectorCondition : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanQuickhack", "Condition.CombatTarget", "Condition.TargetAbove9m", "Condition.NotIsUsingOffMeshLink", "Condition.NotIsMoving", "Condition.NotInRegularCover", "Condition.TargetIsPlayer", "Condition.NotPlayerBeingHacked", {
			OR = 
			[
				{
					AND = 
					[
						"Condition.TargetBelow50m", "Condition.NetrunnerProxy"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow30m", "Condition.TargetIsVisible"
					];
				} : AIActionAND
			];
		} : AIActionOR, 
		{
			OR = 
			[
				"Condition.HackAppliedCooldown", {
					AND = 
					[
						"Condition.AbilityCanPingQuickHack", "Condition.NotMinAccuracyValue1", "Condition.NotNetrunnerProxy"
					];
				} : AIActionAND
			];
		} : AIActionOR, 
		{
			invert = true;
			AND = 
			[
				"Condition.AbilityCanUseCovers", "Condition.IsCoverSelected", "Condition.NotTicketCharge"
			];
		} : AIActionAND
	];
}

HackSelectorCondition_VeryHard : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanQuickhack", "Condition.CombatTarget", "Condition.NotIsUsingOffMeshLink", "Condition.NotIsMoving", "Condition.NotInRegularCover", "Condition.TargetIsPlayer", "Condition.NotPlayerBeingHacked", {
			OR = 
			[
				{
					AND = 
					[
						"Condition.TargetBelow70m", "Condition.NetrunnerProxy"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow50m", "Condition.TargetIsVisible"
					];
				} : AIActionAND
			];
		} : AIActionOR, 
		{
			OR = 
			[
				{
					AND = 
					[
						"Condition.AbilityCanPingQuickHack", "Condition.NotMinAccuracyValue1", "Condition.NotNetrunnerProxy"
					];
				} : AIActionAND
			];
		} : AIActionOR, 
		{
			invert = true;
			AND = 
			[
				"Condition.AbilityCanUseCovers", "Condition.IsCoverSelected", "Condition.NotTicketCharge"
			];
		} : AIActionAND
	];
}

HackSelectorCondition_Hard : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanQuickhack", "Condition.CombatTarget", "Condition.NotIsUsingOffMeshLink", "Condition.NotIsMoving", "Condition.NotInRegularCover", "Condition.TargetIsPlayer", "Condition.NotPlayerBeingHacked", {
			OR = 
			[
				{
					AND = 
					[
						"Condition.TargetBelow70m", "Condition.NetrunnerProxy"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow50m", "Condition.TargetIsVisible"
					];
				} : AIActionAND
			];
		} : AIActionOR, 
		{
			OR = 
			[
				{
					AND = 
					[
						"Condition.AbilityCanPingQuickHack", "Condition.NotMinAccuracyValue1", "Condition.NotNetrunnerProxy"
					];
				} : AIActionAND
			];
		} : AIActionOR, 
		{
			invert = true;
			AND = 
			[
				"Condition.AbilityCanUseCovers", "Condition.IsCoverSelected", "Condition.NotTicketCharge"
			];
		} : AIActionAND
	];
}

CoverHackSelectorCondition : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanQuickhack", "Condition.CombatTarget", "Condition.InCover", "Condition.HackAppliedCooldown", "Condition.TargetAbove9m", "Condition.TargetIsPlayer", "Condition.NotPlayerBeingHacked", {
			OR = 
			[
				{
					AND = 
					[
						"Condition.TargetBelow50m", "Condition.NetrunnerProxy"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow30m", "Condition.TargetIsVisible"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow30m", "Condition.NotFurthestSquadmate", "Condition.MinAccuracyValue0dot95"
					];
				} : AIActionAND
			];
		} : AIActionOR
	];
}

CoverHackSelectorCondition_VeryHard : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanQuickhack", "Condition.CombatTarget", "Condition.InCover", "Condition.TargetIsPlayer", "Condition.NotPlayerBeingHacked", {
			OR = 
			[
				{
					AND = 
					[
						"Condition.TargetBelow70m", "Condition.NetrunnerProxy"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow50m", "Condition.TargetIsVisible"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow30m", "Condition.NotFurthestSquadmate", "Condition.MinAccuracyValue0dot95"
					];
				} : AIActionAND
			];
		} : AIActionOR
	];
}

CoverHackSelectorCondition_Hard : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanQuickhack", "Condition.CombatTarget", "Condition.InCover", "Condition.TargetIsPlayer", "Condition.NotPlayerBeingHacked", {
			OR = 
			[
				{
					AND = 
					[
						"Condition.TargetBelow70m", "Condition.NetrunnerProxy"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow50m", "Condition.TargetIsVisible"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow30m", "Condition.NotFurthestSquadmate", "Condition.MinAccuracyValue0dot95"
					];
				} : AIActionAND
			];
		} : AIActionOR
	];
}

NotValidTargetPositionOrAimCommandCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotAIAimAtTargetCommand", {
			OR = 
			[
				"Condition.NotMaxVisibilityToTargetDistance3m", "Condition.TargetInvalidExpectation"
			];
		} : AIActionOR
	];
}

ValidTargetPositionOrAimCommandCondition : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.MaxVisibilityToTargetDistance3m", "Condition.NotTargetInvalidExpectation", "Condition.MinAccuracyValue0"
			];
		} : AIActionAND, 
		"Condition.AIAimAtTargetCommand"
	];
}

NotValidVisibilityToTargetDistanceFromHip : ValidVisibilityToTargetDistanceFromChest
{
	invert = true;
}

ValidVisibilityToTargetDistanceFromHip : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.MaxVisibilityToTargetDistanceHip3m", {
					OR = 
					[
						"Condition.TargetIsPlayer", "Condition.TargetInCover"
					];
				} : AIActionOR
			];
		} : AIActionAND, 
		"Condition.MaxVisibilityToTargetDistanceHip1dot5m"
	];
}

NotValidVisibilityToTargetDistanceFromChest : ValidVisibilityToTargetDistanceFromChest
{
	invert = true;
}

ValidVisibilityToTargetDistanceFromChest : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.MaxVisibilityToTargetDistanceChest3m", {
					OR = 
					[
						"Condition.TargetIsPlayer", "Condition.TargetInCover"
					];
				} : AIActionOR
			];
		} : AIActionAND, 
		"Condition.MaxVisibilityToTargetDistanceChest1dot5m"
	];
}

NotValidVisibilityToTargetDistance : ValidVisibilityToTargetDistance
{
	invert = true;
}

ValidVisibilityToTargetDistance : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.MaxVisibilityToTargetDistance3m", {
					OR = 
					[
						"Condition.TargetIsPlayer", "Condition.TargetInCover"
					];
				} : AIActionOR
			];
		} : AIActionAND, 
		"Condition.MaxVisibilityToTargetDistance1dot5m"
	];
}

NotValidTargetOrAimCommandCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotAIAimAtTargetCommand", "Condition.TargetInvalidExpectation"
	];
}

ValidTargetOrAimCommandCondition : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.NotTargetInvalidExpectation", "Condition.MinAccuracyValue0"
			];
		} : AIActionAND, 
		"Condition.AIAimAtTargetCommand"
	];
}

NotValidTargetPositionCheckFromChestOrAimCommandCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotAIAimAtTargetCommand", {
			OR = 
			[
				"Condition.NotValidVisibilityToTargetDistanceFromChest", "Condition.TargetInvalidExpectation"
			];
		} : AIActionOR
	];
}

ValidTargetPositionCheckFromChestOrAimCommandCondition : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.ValidVisibilityToTargetDistanceFromChest", "Condition.NotTargetInvalidExpectation", "Condition.MinAccuracyValue0"
			];
		} : AIActionAND, 
		"Condition.AIAimAtTargetCommand"
	];
}

NotValidTargetPositionCheckFromHipOrAimCommandCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotAIAimAtTargetCommand", {
			OR = 
			[
				"Condition.NotValidVisibilityToTargetDistanceFromHip", "Condition.TargetInvalidExpectation"
			];
		} : AIActionOR
	];
}

ValidTargetPositionCheckFromHipOrAimCommandCondition : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.ValidVisibilityToTargetDistanceFromHip", "Condition.NotTargetInvalidExpectation", "Condition.MinAccuracyValue0"
			];
		} : AIActionAND, 
		"Condition.AIAimAtTargetCommand"
	];
}

ShootSelectorCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotCombatTargetChanged", "Condition.NotIsInWorkspot", "Condition.HasRangedWeapon", "Condition.AmmoCountMin1", "Condition.CombatTarget", "Condition.NotInRegularCover", "Condition.NotIsEnteringCover", "Condition.NotIsUsingOffMeshLink", "Condition.NotSprint", "Condition.NotTicketEquip", "Condition.NotTicketSync", "Condition.NotTicketTaunt"
	];
}

NotMoveCommands : AIActionAND
{
	AND = 
	[
		"Condition.NotAIMoveToCommand", "Condition.NotAIMoveOnSplineCommand", "Condition.NotAIAnimMoveOnSplineCommand", "Condition.NotAIFollowTargetCommand", "Condition.NotAIRootMotionCommand", "Condition.NotAIMoveToCoverCommand"
	];
}

MoveCommands : AIActionOR
{
	OR = 
	[
		"Condition.AIMoveToCommand", "Condition.AIMoveOnSplineCommand", "Condition.AIAnimMoveOnSplineCommand", "Condition.AIFollowTargetCommand", "Condition.AIRootMotionCommand", "Condition.AIMoveToCoverCommand"
	];
}

NotShootingInterruptedByCoverConditions : ShootingInterruptedByCoverConditions
{
	invert = true;
}

ShootingInterruptedByCoverConditions : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanUseCovers", "Condition.IsCoverSelected", "Condition.NotInRegularCover", "Condition.NotTicketCharge", "Condition.NotAIHoldPositionCommand", "Condition.NotMoveCommands"
	];
}

CatchUpDistanceConditions : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanSprint", "Condition.AbilityCanCatchUpDistance", {
			OR = 
			[
				"Condition.NotOptimalDistance6mToleranceFailWhenCloser", "Condition.NotInRestrictedMovementArea"
			];
		} : AIActionOR, 
		"Condition.NotValidCoversWithLOSCurrentRing", "Condition.TargetAbove9m", "Condition.PathMovePolicyLongCooldown", "Condition.HitMovePolicyCooldown", "Condition.CatchupDistanceDestinationReachedCooldown"
	];
}

SprintHarassConditions : AIActionAND
{
	AND = 
	[
		"Condition.AbilityHasSandevistan", "Condition.AbilityCanSprintHarass", "Condition.StatusEffectSandevistanBuff", "Condition.CloseRingPathMovePolicyCooldown", "Condition.HitMovePolicyCooldown", "Condition.TargetAbove7m"
	];
}

NotStrafeConditions : AIActionOR
{
	OR = 
	[
		"Condition.NotHitTimeout1", "Condition.NotStrafeCooldownHit", "Condition.InCover", "Condition.NotTicketCheckStrafe"
	];
}

StrafeConditions : AIActionAND
{
	AND = 
	[
		"Condition.HitTimeout1", "Condition.StrafeCooldownHit", "Condition.TicketCheckStrafe"
	];
}

CrowdShootingPauseCondition : AIActionOR
{
	OR = 
	[
		"Condition.TargetAbove90deg", "Condition.FriendlyFire", "Condition.DontShootCombatTarget"
	];
}

ShootingPauseCondition : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.IsInCameraFrustrum", "Condition.NotRightArmLookAtActive"
			];
		} : AIActionAND, 
		"Condition.FriendlyFire", "Condition.DontShootCombatTarget", "Condition.AIAimAtTargetCommand"
	];
}

ShootActivationCondition : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanShootWhileMoving", "Condition.TargetBelow270deg"
	];
}

ShootDeactivationCondition : AIActionOR
{
	OR = 
	[
		"Condition.TicketEquip", "Condition.TargetAbove270deg", "Condition.IsEnteringCover", "Condition.InRegularCover", "Condition.IsUsingOffMeshLink", "Condition.Sprint", "Condition.CombatTargetChanged", {
			AND = 
			[
				"Condition.AmmoCountBelowHalf", "Condition.NotMinAccuracyValue0dot95"
			];
		} : AIActionAND
	];
}

ShootInterruptionCondition : AIActionOR
{
	OR = 
	[
		"Condition.SprintHarassConditions"
	];
}

PreciseShootActivationCondition : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanPreciseShoot", "Condition.NotIsEnteringOrLeavingCover", "Condition.TargetBelow120deg", "Condition.NotIsMoving", "Condition.NotMoveCommands", "Condition.NotTicketStrafe", {
			OR = 
			[
				"Condition.AIHoldPositionCommand", "Condition.OptimalDistance", "Condition.NotRMAMovePolicyCooldown", "Condition.DestinationReached"
			];
		} : AIActionOR, 
		{
			OR = 
			[
				"Condition.AIHoldPositionCommand", {
					invert = true;
					AND = 
					[
						"Condition.AbilityCanUseCovers", "Condition.IsCoverSelected", "Condition.NotTicketCharge"
					];
				} : AIActionAND
			];
		} : AIActionOR
	];
}

PreciseShootDeactivationCondition : AIActionOR
{
	OR = 
	[
		"Condition.TicketEquip", "Condition.AmmoCount0", "Condition.RightArmLookAtOff", "Condition.MoveCommands", "Condition.CombatTargetChanged"
	];
}

ChargedShootActivationCondition : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanChargedShoot", "Condition.HasChargeWeapon", "Condition.MinAccuracyValue0", "Condition.NotMinAccuracyValue0dot95"
	];
}

SniperShootActivationCondition : AIActionAND
{
	AND = 
	[
		"Condition.TargetBelow120deg", "Condition.NotIsMoving", "Condition.NotMoveCommands", {
			OR = 
			[
				"Condition.InShootingSpot", {
					invert = true;
					AND = 
					[
						"Condition.AbilityCanUseCovers", "Condition.IsCoverSelected", "Condition.NotTicketCharge"
					];
				} : AIActionAND
			];
		} : AIActionOR
	];
}

SniperShootDeactivationCondition : AIActionOR
{
	OR = 
	[
		"Condition.TicketEquip", {
			AND = 
			[
				"Condition.TargetBelow9mPrediction", "Condition.NotAIHoldPositionCommand", "Condition.DestinationCalculated", "Condition.DestinationChanged"
			];
		} : AIActionAND, 
		"Condition.ShootingInterruptedByCoverConditions", "Condition.RightArmLookAtOff", "Condition.AmmoCount0", "Condition.MoveCommands", "Condition.CombatTargetChanged"
	];
}

SniperShootInterruptionCondition : AIActionOR
{
	OR = 
	[
		"Condition.ShootingInterruptedByCoverConditions", "Condition.StrafeConditions", "Condition.IsMoving", {
			AND = 
			[
				"Condition.NotHitTimeout7", "Condition.CalculatePathStraightFullCheckToTarget", "Condition.TargetAbove15m"
			];
		} : AIActionAND
	];
}

MountVehicleCondition : AIActionAND
{
	AND = 
	[
		"Condition.AssignedVehicle", "Condition.NotIsFollower", "Condition.NotTicketEquip", "Condition.NotAIThrowGrenadeCommand", "Condition.NotAIMoveCommand", "Condition.NotAIUseWorkspotCommand", "Condition.NotAIUseCoverCommandValid", "Condition.VehicleUnmountCooldown"
	];
}

MountVehicleInCombatCondition : AIActionAND
{
	AND = 
	[
		"Condition.TargetAbove15m", "Condition.AssignedVehicleBelow10m", "Condition.AssignedVehicle", "Condition.NotIsFollower", "Condition.NotTicketEquip", "Condition.NotAIThrowGrenadeCommand", "Condition.NotAIMoveCommand", "Condition.NotAIUseWorkspotCommand", "Condition.NotAIUseCoverCommandValid", "Condition.VehicleUnmountCooldown"
	];
}

ThrowGrenadeSelectorCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotAIThrowGrenadeCommand", "Condition.NotAIAimAtTargetCommand", "Condition.NotTicketCatchUp", "Condition.MinAccuracyValue0", "Condition.BaseThrowGrenadeSelectorCondition", "Condition.TargetNotPlayerFollower", "Condition.NotIsFollower", "Condition.NotTargetInSafeZone"
	];
}

BaseThrowGrenadeSelectorCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotHasAnyWeaponLeft", "Condition.AbilityCanUseGrenades", "Condition.NotIsInWorkspot", "Condition.NotIsUsingOffMeshLink", "Condition.NotInRegularCover", "Condition.NotIsEnteringOrLeavingCover", "Condition.ThrowCond", "Condition.NotIsFollower", "Condition.NotTicketEquip", "Condition.HasAnyWeapon", "Condition.NotTicketSync", "Condition.NotTicketTakeCover"
	];
}

ThrowGrenadeSelectorCondition_VeryHard : AIActionAND
{
	AND = 
	[
		"Condition.NotAIThrowGrenadeCommand", "Condition.NotAIAimAtTargetCommand", "Condition.NotTicketCatchUp", "Condition.MinAccuracyValue0", "Condition.BaseThrowGrenadeSelectorCondition_VeryHard", "Condition.TargetNotPlayerFollower", "Condition.NotIsFollower", "Condition.TargetIsPlayer", "Condition.NotTargetInSafeZone"
	];
}

BaseThrowGrenadeSelectorCondition_VeryHard : AIActionAND
{
	AND = 
	[
		"Condition.NotHasAnyWeaponLeft", "Condition.NotIsInWorkspot", "Condition.NotIsUsingOffMeshLink", "Condition.NotInRegularCover", "Condition.NotIsEnteringOrLeavingCover", "Condition.ThrowCond", "Condition.NotIsFollower", "Condition.NotTicketEquip", "Condition.HasAnyWeapon", "Condition.NotTicketSync", "Condition.NotTicketTakeCover"
	];
}

CoverThrowGrenadeSelectorCondition : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanUseGrenades", "Condition.NotHasAnyWeaponLeft", "Condition.NotTicketEquip", "Condition.NotTicketSync", "Condition.ThrowCond", "Condition.TargetNotPlayerFollower", "Condition.NotIsFollower", "Condition.CheckChosenExposureMethodAll", "Condition.NotTargetInSafeZone"
	];
}

CoverThrowGrenadeSelectorCondition_VeryHard : AIActionAND
{
	AND = 
	[
		"Condition.NotHasAnyWeaponLeft", "Condition.NotTicketEquip", "Condition.NotTicketSync", "Condition.ThrowCond", "Condition.TargetNotPlayerFollower", "Condition.NotIsFollower", "Condition.CheckChosenExposureMethodAll", "Condition.NotTargetInSafeZone"
	];
}

CoverThrowGrenadeSelectorCondition_Hard : AIActionAND
{
	AND = 
	[
		"Condition.NotHasAnyWeaponLeft", "Condition.NotTicketEquip", "Condition.NotTicketSync", "Condition.ThrowCond", "Condition.TargetNotPlayerFollower", "Condition.NotIsFollower", "Condition.TargetIsPlayer", "Condition.CheckChosenExposureMethodAll", "Condition.NotTargetInSafeZone"
	];
}

ThrowGrenadeCondition : AIActionAND
{
	AND = 
	[
		{
			target = "AIActionTarget.CombatTarget";
			distance = ( 15.f, 30.f );
			coneAngle = ( -1.f, 60.f );
		} : AISpatialCond, 
		"Condition.InitThrowGrenadeCooldown", "Condition.CalculatePathStraightToTarget1mBack", "Condition.HasRangedWeapon", {
			OR = 
			[
				"Condition.NotCalculatePathStraightToTarget10mForwardOffset", "Condition.TargetInVehicle"
			];
		} : AIActionOR
	];
}

ThrowGrenadeCondition_VeryHard : AIActionAND
{
	AND = 
	[
		{
			target = "AIActionTarget.CombatTarget";
			distance = ( 5.f, 60.f );
			coneAngle = ( -1.f, 60.f );
		} : AISpatialCond, 
		"Condition.CalculatePathStraightToTarget1mBack", "Condition.HasRangedWeapon", {
			OR = 
			[
				"Condition.NotCalculatePathStraightToTarget10mForwardOffset", "Condition.TargetInVehicle"
			];
		} : AIActionOR
	];
}

ThrowKnifeCondition : AIActionAND
{
	AND = 
	[
		{
			target = "AIActionTarget.CombatTarget";
			distance = ( 15.f, 30.f );
			coneAngle = ( -1.f, 60.f );
		} : AISpatialCond, 
		"Condition.InitThrowGrenadeCooldown", "Condition.CalculatePathStraightToTarget1mBack", {
			OR = 
			[
				"Condition.NotCalculatePathStraightToTarget10mForwardOffset", "Condition.TargetInVehicle"
			];
		} : AIActionOR
	];
}

ThrowGrenadeNearCondition : AIActionAND
{
	AND = 
	[
		{
			target = "AIActionTarget.CombatTarget";
			distance = ( 10.f, 15.f );
			coneAngle = ( -1.f, 60.f );
		} : AISpatialCond
	];
}

ReloadSelectorCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotAbilityHasAutoReloader", "Condition.HasRangedWeapon", "Condition.AmmoCountBelowHalf", "Condition.ReloadCooldown", "Condition.NotInRegularCover", "Condition.NotIsEnteringOrLeavingCover", "Condition.NotTicketEquip", "Condition.NotTicketSync", "Condition.NotIsUsingOffMeshLink"
	];
}

NotAIUseCoverCommandValid : AIUseCoverCommandValid
{
	invert = true;
}

AIUseCoverCommandValid : AIActionAND
{
	AND = 
	[
		"Condition.AIUseCoverCommand", "Condition.AbilityCanUseCovers", "Condition.IsCoverSelected"
	];
}

NotHackingInterruptedStatusEffects : AIActionAND
{
	AND = 
	[
		"Condition.NotStatusEffectTypeCyberwareMalfunction"
	];
}

HackingInterruptedStatusEffects : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypeCyberwareMalfunction"
	];
}

CanHack : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.NotFurthestSquadmate", "Condition.MinAccuracyValue0dot33"
			];
		} : AIActionAND, 
		"Condition.NetrunnerProxy"
	];
}

NotCanMoveInRegardsToShooting : CanMoveInRegardsToShooting
{
	invert = true;
}

CanMoveInRegardsToShooting : AIActionOR
{
	OR = 
	[
		"Condition.AbilityCanShootWhileMoving", "Condition.NotInStatesShoot"
	];
}

IsNPCBleeding : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypeBleeding"
	];
}

IsNPCStunned : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypeStun"
	];
}

IsNPCBurning : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypeBurning"
	];
}

IsNPCPoisoned : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypePoisoned", "Condition.StatusEffectDrugged", "Condition.StatusEffectDruggedSevere"
	];
}

IsNPCBlindedRegular : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectBlind", "Condition.StatusEffectMajorBlind", "Condition.StatusEffectMinorBlind"
	];
}

NotIsNPCBlinded : AIActionAND
{
	AND = 
	[
		"Condition.NotStatusEffectTypeBlind", "Condition.NotStatusEffectMemoryWipeLevel2", "Condition.NotStatusEffectMemoryWipeLevel3", "Condition.NotStatusEffectMemoryWipeLevel4", "Condition.NotStatusEffectBossMemoryWipe"
	];
}

IsNPCBlinded : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypeBlind", "Condition.StatusEffectMemoryWipeLevel2", "Condition.StatusEffectMemoryWipeLevel3", "Condition.StatusEffectMemoryWipeLevel4", "Condition.StatusEffectBossMemoryWipe"
	];
}

NotIsNPCBlindedFromQuickhack : AIActionAND
{
	AND = 
	[
		"Condition.NotStatusEffectTagQuickHackBlind", "Condition.NotStatusEffectMemoryWipeLevel2", "Condition.NotStatusEffectMemoryWipeLevel3", "Condition.NotStatusEffectMemoryWipeLevel4", "Condition.NotStatusEffectBossMemoryWipe"
	];
}

IsNPCBlindedFromQuickhack : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTagQuickHackBlind", "Condition.StatusEffectMemoryWipeLevel2", "Condition.StatusEffectMemoryWipeLevel3", "Condition.StatusEffectMemoryWipeLevel4", "Condition.StatusEffectBossMemoryWipe"
	];
}

IsNPCUnderLocomotionMalfunctionQuickhack : AIActionAND
{
	AND = 
	[
		"Condition.NotInStatesCombat", "Condition.NotStatusEffectPreventQHStaggerAnimation", "Condition.StatusEffectTypeLocomotionMalfunction"
	];
}

NotIsNPCUnderLocomotionMalfunctionQuickhack : IsNPCUnderLocomotionMalfunctionQuickhack
{
	invert = true;
}

NotIsNPCUnderFreezeLocomotionMalfunctionQuickhack : AIActionAND
{
	AND = 
	[
		"Condition.StatusEffectTypeFreezeLocomotionMalfunction"
	];
}

IsNPCUnderFreezeLocomotionMalfunctionQuickhack : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypeFreezeLocomotionMalfunction"
	];
}

NotIsNPCUnderCyberwareMalfunctionQuickhack : AIActionAND
{
	AND = 
	[
		"Condition.NotStatusEffectTypeCyberwareMalfunction"
	];
}

IsNPCUnderCyberwareMalfunctionQuickhack : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypeCyberwareMalfunction"
	];
}

NotIsNPCUnderWeaponMalfunctionQuickhack : AIActionAND
{
	AND = 
	[
		"Condition.NotStatusEffectTypeWeaponMalfunction"
	];
}

IsNPCUnderWeaponMalfunctionQuickhack : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypeWeaponMalfunction"
	];
}

IsNPCElectrocuted : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypeEMP"
	];
}

NotCommNoise : AIActionAND
{
	AND = 
	[
		"Condition.NotStatusEffectTypeCommsNoise"
	];
}

CommNoise : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectTypeCommsNoise"
	];
}

GracefulCombatInterruptionCompound : AIActionAND
{
	AND = 
	[
		"Condition.GracefulCombatInterruption", "Condition.NotSprint"
	];
}

CanGoToMediumRingCovers : AIActionAND
{
	AND = 
	[
		"Condition.TicketCheckMediumRing", "Condition.ValidCoversMedium"
	];
}

CanGoToFarRingCovers : AIActionAND
{
	AND = 
	[
		"Condition.TicketCheckFarRing", "Condition.ValidCoversFar"
	];
}

CanGoToExtremeRingCovers : AIActionAND
{
	AND = 
	[
		"Condition.TicketCheckExtremeRing", "Condition.ValidCoversExtreme"
	];
}

MeleeCloseAttackDirectionalCondition : AIActionAND
{
	AND = 
	[
		"Condition.CalculatePathStraightToTarget", "Condition.AbilityCanUseRightHand", "Condition.AbilityCanUseLeftHand", "Condition.TargetBelow2m"
	];
}

MeleeCloseAttackFrontCondition : AIActionAND
{
	AND = 
	[
		"Condition.CalculatePathStraightFullCheckToTarget", "Condition.AbilityCanUseRightHand", "Condition.AbilityCanUseLeftHand", "Condition.TargetBelow3m", "Condition.TargetBelow120deg"
	];
}

MeleeAttackCondition : AIActionAND
{
	AND = 
	[
		"Condition.CalculatePathToTarget", "Condition.AbilityCanUseRightHand", "Condition.AbilityCanUseLeftHand", "Condition.AbilityCanUseLegs", "Condition.TargetAbove0dot2m", {
			OR = 
			[
				"Condition.NotTargetInStatesBlock", "Condition.TargetAbove2m"
			];
		} : AIActionOR, 
		{
			OR = 
			[
				"Condition.NotAbilityHasSandevistan", "Condition.TargetAbove2m", "Condition.TargetBelow3m"
			];
		} : AIActionOR
	];
}

SimpleMeleeAttackConditions : AIActionAND
{
	AND = 
	[
		"Condition.NotTargetInVehicle"
	];
}

MeleeAttackSandevistanCondition : AIActionAND
{
	AND = 
	[
		"Condition.CalculatePathToTarget", "Condition.AbilityCanUseRightHand", "Condition.AbilityCanUseLeftHand", "Condition.AbilityCanSprint", "Condition.AbilityCanUseLegs", "Condition.AbilityHasSandevistan", "Condition.TargetAbove4m"
	];
}

MeleeChargeSandevistanCondition : AIActionAND
{
	AND = 
	[
		"Condition.CalculatePathToTarget", "Condition.AbilityCanSprint", "Condition.AbilityCanUseRightHand", "Condition.AbilityCanUseLegs", "Condition.AbilityHasSandevistan"
	];
}

MeleeChargeJumpCondition : AIActionAND
{
	AND = 
	[
		"Condition.CalculatePathToTarget", "Condition.AbilityCanUseRightHand", "Condition.AbilityCanUseLegs", "Condition.AbilityHasChargeJump", "Condition.AbilityIsStrongMeleeArchetype", "Condition.TargetAbove7mLongPrediction", "Condition.TargetBelow45deg", "Condition.TargetPOVBelow90deg", "Condition.NotTargetHeadingToOwnerDotProduct"
	];
}

NoWeaponCombatSprintToFollowerCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotIsFriendInVeryFarRange", "Condition.AbilityCanSprint"
	];
}

CombatTooFarToFollowerCondition : AIActionAND
{
	AND = 
	[
		{
			OR = 
			[
				"Condition.FollowerAbove3dot7zDiff", "Condition.NotIsFriendInVeryFarRange"
			];
		} : AIActionOR, 
		"Condition.CalculatePathToFollower"
	];
}

CombatStopChasingTargetCondition : AIActionAND
{
	AND = 
	[
		{
			OR = 
			[
				"Condition.FollowerAbove3dot7zDiff", {
					spatialHintMults = ( 0.8f, 1.2f, 1.7f );
				} : Condition.NotIsFriendInFarRange
			];
		} : AIActionOR, 
		"Condition.CalculatePathToFollower"
	];
}

CombatSprintToFollowerCondition : AIActionAND
{
	AND = 
	[
		"Condition.CombatTooFarToFollowerCondition", "Condition.AbilityCanSprint"
	];
}

CombatStayCloseToFollowerCondition : AIActionAND
{
	AND = 
	[
		{
			OR = 
			[
				"Condition.FollowerAbove3dot7zDiff", "Condition.NotIsFriendInFarRange"
			];
		} : AIActionOR, 
		"Condition.CalculatePathToFollower"
	];
}

CombatMovementInterruptionCondition : AIActionOR
{
	OR = 
	[
		"Condition.CombatTargetChanged", "Condition.TicketTakeCover", "Condition.IsEnteringOrLeavingCover", "Condition.AIMoveCommand", "Condition.AIUseWorkspotCommand", "Condition.InterruptRingAction"
	];
}

SprintToFollowerInterruptionCondition : AIActionOR
{
	OR = 
	[
		"Condition.IsFriendInMiddleRange", "Condition.PathFindingFailed", {
			AND = 
			[
				"Condition.IsFriendInFarRange", "Condition.TicketTakeCover"
			];
		} : AIActionAND
	];
}

KeepDistanceToCombatTargetInterruptionCondition : AIActionOR
{
	OR = 
	[
		{
			AND = 
			[
				"Condition.PathMovePolicyLongCooldown", "Condition.NotMinAccuracyValue0dot95", "Condition.NotTargetIsVisible"
			];
		} : AIActionAND, 
		{
			AND = 
			[
				"Condition.NotIsFriendInFarRange", "Condition.CalculatePathToFollower"
			];
		} : AIActionAND
	];
}

ShortenDistanceToCombatTargetInterruptionCondition : AIActionOR
{
	OR = 
	[
		"Condition.CombatSprintToFollowerCondition", "Condition.InStatesStatic", {
			AND = 
			[
				"Condition.MinAccuracyValue0dot95", "Condition.TargetIsVisible"
			];
		} : AIActionAND, 
		{
			AND = 
			[
				"Condition.NotIsFriendInFarRange", "Condition.CalculatePathToFollower"
			];
		} : AIActionAND
	];
}

NotIncreaseFollowingSpeedCondition : IncreaseFollowingSpeedCondition
{
	invert = true;
}

IncreaseFollowingSpeedCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotIsInCameraFrustrum", "Condition.IsMoving", "Condition.NotActionStatesConditions"
	];
}

NotEnterStealthCondition : EnterStealthCondition
{
	invert = true;
}

EnterStealthCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotIsUsingOffMeshLink", "Condition.SwitchStatesCooldown", "Condition.NotFriendlyTargetInStatesSprint", "Condition.NotIsEnteringOrLeavingCover", "Condition.NotTicketEquip", "Condition.NotStatusEffectFollowerGameplayRestrictionNoCombat", {
			OR = 
			[
				"Condition.FriendlyTargetInStatesCrouch", "Condition.TopThreatMinAccuracySharedValue0dot5"
			];
		} : AIActionOR
	];
}

LeaveStealthCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotIsUsingOffMeshLink", "Condition.SwitchStatesCooldown", "Condition.NotFriendlyTargetInStatesCrouch", "Condition.NotIsEnteringOrLeavingCover", "Condition.NotTicketEquip", "Condition.NotStatusEffectFollowerDontLeaveStealth", {
			OR = 
			[
				"Condition.FriendlyTargetInStatesSprint", "Condition.NotTopThreatMinAccuracySharedValue0dot5", "Condition.StatusEffectFollowerGameplayRestrictionNoCombat"
			];
		} : AIActionOR
	];
}

NotEnterCoverCondition : EnterCoverCondition
{
	invert = true;
}

EnterCoverCondition : AIActionAND
{
	AND = 
	[
		"Condition.IsCoverSelected", "Condition.IsCoverInMiddleRange", "Condition.NotAIMoveCommand", "Condition.NotAIUseWorkspotCommand", "Condition.NotIsUsingOffMeshLink", "Condition.TopThreat", "Condition.NotEnterVehicleAICondition"
	];
}

NotEnterVehicleAICondition : EnterVehicleAICondition
{
	invert = true;
}

EnterVehicleAICondition : AIActionAND
{
	AND = 
	[
		"Condition.FollowerDrivingVehicle", "Condition.NotOnMotorcycle", "Condition.NotStatusEffectDoNotUseVehicle"
	];
}

NotGetOutOfWayDoublePredictionCond : GetOutOfWayDoublePredictionCond
{
	invert = true;
}

GetOutOfWayDoublePredictionCond : IsFriendHeadingOwner
{
	AND += 
	[
		"Condition.NotInRegularCover", "Condition.GetOutOfWayPredictionCond"
	];
}

IsFriendHeadingOwner : AIActionAND
{
	AND = 
	[
		"Condition.IsFriendMoving", "Condition.FriendHeadingToOwnerDotProduct"
	];
}

IsFriendMovingInOppositeDirection : AIActionAND
{
	AND = 
	[
		"Condition.IsFriendMoving", "Condition.FriendMovingInOppositeDirectionDotProduct"
	];
}

LeaveGetOutOfWayCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotIsUsingOffMeshLink", "Condition.NotGetOutOfWayPredictionCond", {
			OR = 
			[
				"Condition.NotIsMoving", {
					AND = 
					[
						"Condition.FollowerAbove4m", "Condition.IsFriendMovingInOppositeDirection"
					];
				} : AIActionAND
			];
		} : AIActionOR
	];
}

NotFollowFarEnterCondition : FollowFarEnterCondition
{
	invert = true;
}

FollowFarEnterCondition : AIActionAND
{
	AND = 
	[
		"Condition.AbilityCanSprint", "Condition.NotEnterStealthCondition", {
			OR = 
			[
				{
					AND = 
					[
						"Condition.FriendlyTargetInStatesSprint", "Condition.NotIsDistanceToDestinationInFarRange"
					];
				} : AIActionAND, 
				"Condition.NotIsDistanceToDestinationInVeryFarRange"
			];
		} : AIActionOR
	];
}

FollowFarStopCondition : AIActionAND
{
	AND = 
	[
		"Condition.NotIsUsingOffMeshLink", {
			OR = 
			[
				"Condition.GetOutOfWayDoublePredictionCond", "Condition.EnterVehicleAICondition", {
					AND = 
					[
						"Condition.NotFriendlyTargetInStatesSprint", "Condition.IsDistanceToDestinationInMediumRange"
					];
				} : AIActionAND
			];
		} : AIActionOR
	];
}

LeavingTurningCond : AIActionOR
{
	OR = 
	[
		"Condition.NotIsMoving", "Condition.FollowFarEnterCondition", "Condition.EnterStealthCondition", "Condition.EnterVehicleAICondition", "Condition.GetOutOfWayDoublePredictionCond", "Condition.DistanceToDestinationAbove1m", "Condition.EnterCoverCondition"
	];
}

LeavingStayingCond : AIActionOR
{
	OR += 
	[
		{
			AND = 
			[
				"Condition.AbilityCanSprint", {
					OR = 
					[
						{
							AND = 
							[
								"Condition.FriendlyTargetInStatesSprint", "Condition.NotIsDistanceToDestinationInFarRange"
							];
						} : AIActionAND, 
						"Condition.NotIsDistanceToDestinationInVeryFarRange"
					];
				} : AIActionOR
			];
		} : AIActionAND, 
		"Condition.EnterStealthCondition", "Condition.EnterVehicleAICondition", "Condition.GetOutOfWayDoublePredictionCond", "Condition.DistanceToDestinationAbove1m", "Condition.EnterCoverCondition"
	];
}

LeavingTurningStealthCond : AIActionOR
{
	OR = 
	[
		"Condition.NotIsMoving", "Condition.LeaveStealthCondition", "Condition.EnterVehicleAICondition", "Condition.GetOutOfWayDoublePredictionCond", "Condition.DistanceToDestinationAbove1m", "Condition.EnterCoverCondition"
	];
}

LeavingStayingStealthCond : BaseLeavingStaying
{
	OR += 
	[
		"Condition.LeaveStealthCondition"
	];
}

BaseLeavingStaying : AIActionOR
{
	OR = 
	[
		"Condition.EnterVehicleAICondition", "Condition.GetOutOfWayDoublePredictionCond", "Condition.DistanceToDestinationAbove1m", "Condition.EnterCoverCondition"
	];
}

NotMeleeAvoidLOSCondition : Condition.MeleeAvoidLOSCondition
{
	invert = true;
}

MeleeAvoidLOSCondition : AIActionAND
{
	AND = 
	[
		{
			OR = 
			[
				{
					AND = 
					[
						"Condition.TargetHasRangedWeapon", "Condition.AbilityIsDefensive"
					];
				} : AIActionAND, 
				"Condition.AbilityIsCautious"
			];
		} : AIActionOR, 
		{
			OR = 
			[
				"Condition.TargetAbove12m", {
					AND = 
					[
						"Condition.TargetAbove7m", "Condition.NotIsInCameraFrustrum"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetAbove9m", "Condition.AbilityIsCautious"
					];
				} : AIActionAND
			];
		} : AIActionOR, 
		"Condition.AvoidLOSMovePolicyCooldown", "Condition.NotIsUsingOffMeshLink", "Condition.PathMovePolicyLongCooldown"
	];
}

NotAbilityIsCrowd : AbilityIsCrowd
{
	invert = true;
}

AbilityIsCrowd : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsCrowdNPC"
	];
}

NotAbilityIsTier3Archetype : AbilityIsTier3Archetype
{
	invert = true;
}

AbilityIsTier3Archetype : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsTier3Archetype"
	];
}

NotAbilityIsAVMaxTac : AbilityIsAVMaxTac
{
	invert = true;
}

AbilityIsAVMaxTac : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsAVMaxTac"
	];
}

NotAbilityIsTier2Archetype : AbilityIsTier2Archetype
{
	invert = true;
}

AbilityIsTier2Archetype : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsTier2Archetype"
	];
}

NotAbilityIsTier1Archetype : AbilityIsTier1Archetype
{
	invert = true;
}

AbilityIsTier1Archetype : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsTier1Archetype"
	];
}

NotAbilityCanCallReinforcements : AbilityCanCallReinforcements
{
	invert = true;
}

AbilityCanCallReinforcements : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanCallReinforcements"
	];
}

NotAbilitySandevistanDashShoot : AbilitySandevistanDashShoot
{
	invert = true;
}

AbilitySandevistanDashShoot : AIAbilityCond
{
	abilities = 
	[
		"Ability.SandevistanDashShoot"
	];
}

NotAbilityHasSandevistan : AbilityHasSandevistan
{
	invert = true;
}

AbilityHasSandevistan : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasSandevistan"
	];
}

NotAbilityHasSandevistanTier2 : AbilityHasSandevistanTier2
{
	invert = true;
}

AbilityHasSandevistanTier2 : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasSandevistanTier2"
	];
}

NotAbilityHasBerserk : AbilityHasBerserk
{
	invert = true;
}

AbilityHasBerserk : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasBerserk"
	];
}

NotAbilityHasJuiceInjector : AbilityHasJuiceInjector
{
	invert = true;
}

AbilityHasJuiceInjector : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasJuiceInjector"
	];
}

AbilityCanCatchUpDistance : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanCatchUpDistance"
	];
}

AbilityCanCatchUp : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanCatchUp"
	];
}

AbilityCanTaunt : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanTaunt"
	];
}

AbilityCanThrowWeapon : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanThrowWeapon"
	];
}

AbilityCanGuardBreak : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanGuardBreak"
	];
}

AbilityCanGrab : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanGrab"
	];
}

NotAbilityCanPickUpWeapon : AbilityCanPickUpWeapon
{
	invert = true;
}

AbilityCanPickUpWeapon : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanPickUpWeapon"
	];
}

NotAbilityIsReckless : AbilityIsReckless
{
	invert = true;
}

AbilityIsReckless : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsReckless"
	];
}

NotAbilityIsAggressive : AbilityIsAggressive
{
	invert = true;
}

AbilityIsAggressive : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsAggressive"
	];
}

NotAbilityIsBalanced : AbilityIsBalanced
{
	invert = true;
}

AbilityIsBalanced : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsBalanced"
	];
}

NotAbilityIsDefensive : AbilityIsDefensive
{
	invert = true;
}

AbilityIsDefensive : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsDefensive"
	];
}

NotAbilityIsCautious : AbilityIsCautious
{
	invert = true;
}

AbilityIsCautious : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsCautious"
	];
}

NotAbilityIsShotgunnerArchetype : AbilityIsShotgunnerArchetype
{
	invert = true;
}

AbilityIsShotgunnerArchetype : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsShotgunnerArchetype"
	];
}

NotAbilityIsHeavyRangedArchetype : AbilityIsHeavyRangedArchetype
{
	invert = true;
}

AbilityIsHeavyRangedArchetype : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsHeavyRangedArchetype"
	];
}

NotAbilityIsSniperArchetype : AbilityIsSniperArchetype
{
	invert = true;
}

AbilityIsSniperArchetype : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsSniperArchetype"
	];
}

NotAbilityIsNetrunnerArchetype : AbilityIsNetrunnerArchetype
{
	invert = true;
}

AbilityIsNetrunnerArchetype : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsNetrunnerArchetype"
	];
}

NotAbilityCanSprintHarass : AbilityCanSprintHarass
{
	invert = true;
}

AbilityCanSprintHarass : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanSprintHarass"
	];
}

NotAbilityCanSprint : AbilityCanSprint
{
	invert = true;
}

AbilityCanSprint : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanSprint"
	];
}

NotAbilityCanUseCovers : AbilityCanUseCovers
{
	invert = true;
}

AbilityCanUseCovers : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseCovers"
	];
}

NotAbilityCanUseLegs : AbilityCanUseLegs
{
	invert = true;
}

AbilityCanUseLegs : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseLegs"
	];
}

NotAbilityIsStrongMeleeArchetype : AbilityIsStrongMeleeArchetype
{
	invert = true;
}

AbilityIsStrongMeleeArchetype : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsStrongMeleeArchetype"
	];
}

NotAbilityIsFastMeleeArchetype : AbilityIsFastMeleeArchetype
{
	invert = true;
}

AbilityIsFastMeleeArchetype : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsFastMeleeArchetype"
	];
}

NotAbilityHasChargeJump : AbilityHasChargeJump
{
	invert = true;
}

AbilityHasChargeJump : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasChargeJump"
	];
}

NotAbilityCanDash : AbilityCanDash
{
	invert = true;
}

AbilityCanDash : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanDash"
	];
}

NotAbilityCanUseCombatStims : AbilityCanUseCombatStims
{
	invert = true;
}

AbilityCanUseCombatStims : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseCombatStims"
	];
}

NotAbilityCanUseGrenades : AbilityCanUseGrenades
{
	invert = true;
}

AbilityCanUseGrenades : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseGrenades"
	];
}

AbilityCanCloseCombat : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanCloseCombat"
	];
}

AbilityCanResurrectAllies : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanResurrectAllies"
	];
}

NotAbilityCanUseRightHand : AbilityCanUseRightHand
{
	invert = true;
}

AbilityCanUseRightHand : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseRightHand"
	];
}

NotAbilityCanUseLeftHand : AbilityCanUseLeftHand
{
	invert = true;
}

AbilityCanUseLeftHand : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseLeftHand"
	];
}

AbilityHasGlowingTattoos : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasGlowingTattoos"
	];
}

NotAbilityHasKerenzikov : AbilityHasKerenzikov
{
	invert = true;
}

AbilityHasKerenzikov : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasKerenzikov"
	];
}

NotAbilityCanBlock : AbilityCanBlock
{
	invert = true;
}

AbilityCanBlock : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanBlock"
	];
}

NotAbilityCanParry : AbilityCanParry
{
	invert = true;
}

AbilityCanParry : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanParry"
	];
}

AbilityCanQuickhack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanQuickhack"
	];
}

NotAbilityHasAutoReloader : AbilityHasAutoReloader
{
	invert = true;
}

AbilityHasAutoReloader : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasAutoReloader"
	];
}

NotAbilityHasMajorQuickhackResistance : AbilityHasMajorQuickhackResistance
{
	invert = true;
}

AbilityHasMajorQuickhackResistance : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasMajorQuickhackResistance"
	];
}

NotAbilityHasQuickhackResistance : AbilityHasQuickhackResistance
{
	invert = true;
}

AbilityHasQuickhackResistance : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasQuickhackResistance"
	];
}

NotTargetHasImmunityToNPCQuickhacks : TargetHasImmunityToNPCQuickhacks
{
	invert = true;
}

TargetHasImmunityToNPCQuickhacks : AIAbilityCond
{
	target = "AIActionTarget.CombatTarget";
	abilities = 
	[
		"Ability.HasImmunityToNPCQuickhacks"
	];
}

NotAbilityCanSwitchWeapon : AbilityCanSwitchWeapon
{
	invert = true;
}

AbilityCanSwitchWeapon : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanSwitchWeapon"
	];
}

AbilityCanPreciseShoot : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanPreciseShoot"
	];
}

AbilityCanShootWhileMoving : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanShootWhileMoving"
	];
}

AbilityCanChargedShoot : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanChargedShoot"
	];
}

AbilityCanUseFragGrenades : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseFragGrenades"
	];
}

AbilityCanUseFlashbangGrenades : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseFlashbangGrenades"
	];
}

AbilityCanUseEMPGrenades : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseEMPGrenades"
	];
}

AbilityCanUseBiohazardGrenades : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseBiohazardGrenades"
	];
}

AbilityCanUseIncendiaryGrenades : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseIncendiaryGrenades"
	];
}

AbilityCanUseReconGrenades : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseReconGrenades"
	];
}

AbilityCanUseCuttingGrenades : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseCuttingGrenades"
	];
}

AbilityCanUseSmokeGrenades : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseSmokeGrenades"
	];
}

AbilityHasDodge : AIAbilityCond
{
	abilities = 
	[
		"Ability.HasDodge"
	];
}

AbilityCanAskToFollowOrder : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanAskToFollowOrder"
	];
}

NotAbilityCanExitWSOnSoundStimuli : AbilityCanExitWSOnSoundStimuli
{
	invert = true;
}

AbilityCanExitWSOnSoundStimuli : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanExitWSOnSoundStimuli"
	];
}

NotAbilityIsTechieArchetype : AbilityIsTechieArchetype
{
	invert = true;
}

AbilityIsTechieArchetype : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsTechieArchetype"
	];
}

AbilityCanUseMeleeRing : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseMeleeRing"
	];
}

AbilityCanUseCloseRing : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseCloseRing"
	];
}

AbilityCanUseMediumRing : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseMediumRing"
	];
}

AbilityCanUseFarRing : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseFarRing"
	];
}

AbilityCanUseExtremeRing : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseExtremeRing"
	];
}

AbilityCanSeeThroughWalls : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanSeeThroughWalls"
	];
}

AbilityCanUseOpticalCamo : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanUseOpticalCamo"
	];
}

AbilityCanPingQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanPingQuickHack"
	];
}

AbilityCanLocomotionMalfunctionQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanLocomotionMalfunctionQuickHack"
	];
}

AbilityCanOverloadQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanOverloadQuickHack"
	];
}

AbilityCanOverheatQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanOverheatQuickHack"
	];
}

AbilityCanDeathQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanDeathQuickHack"
	];
}

AbilityCanWeaponMalfunctionQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanWeaponMalfunctionQuickHack"
	];
}

AbilityCanBuffCamoQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanBuffCamoQuickHack"
	];
}

AbilityCanBuffSturdinessQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanBuffSturdinessQuickHack"
	];
}

AbilityCanBlindQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanBlindQuickHack"
	];
}

AbilityCanJamWeaponQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanJamWeaponQuickHack"
	];
}

AbilityCanCyberwareMalfunctionQuickHack : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanCyberwareMalfunctionQuickHack"
	];
}

NotAbilityIsExo : AbilityIsExo
{
	invert = true;
}

AbilityIsExo : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsExo"
	];
}

NotGracefulCombatInterruption : GracefulCombatInterruption
{
	invert = true;
}

GracefulCombatInterruption : AISignalCond
{
	name = "GracefulCombatInterruption";
}

NotInterruptTaunts : InterruptTaunts
{
	invert = true;
}

InterruptTaunts : AISignalCond
{
	name = "InterruptTaunts";
}

NotGracefullyInterruptMoveToCover : GracefullyInterruptMoveToCover
{
	invert = true;
}

GracefullyInterruptMoveToCover : AISignalCond
{
	name = "GracefullyInterruptMoveToCover";
}

InterruptRingAction : AISignalCond
{
	name = "InterruptRingAction";
}

InterruptMeleeAction : AISignalCond
{
	name = "InterruptMeleeAction";
}

InterruptCoverSelection : AISignalCond
{
	name = "InterruptCoverSelection";
}

HackingCompleted : AISignalCond
{
	name = "HackingCompleted";
}

PatrolEnded : AISignalCond
{
	name = "PatrolEnded";
}

NotCombatTargetChanged : CombatTargetChanged
{
	invert = true;
}

CombatTargetChanged : AISignalCond
{
	name = "CombatTargetChanged";
}

AnimationsLoaded : AISignalCond
{
	name = "AnimationsLoaded";
}

RecentIncapacitationInSquad : AISignalCond
{
	name = "RecentIncapacitationInSquad";
}

NotWaitForCompanionSignal : WaitForCompanionSignal
{
	invert = true;
}

WaitForCompanionSignal : AISignalCond
{
	name = "WaitForCompanion";
}

NotBlockSignal : BlockSignal
{
	invert = true;
}

BlockSignal : AISignalCond
{
	name = "BlockSignal";
}

NotHitSignal : HitSignal
{
	invert = true;
}

HitSignal : AISignalCond
{
	name = "HitSignal";
}

NotKnockdownSignal : KnockdownSignal
{
	invert = true;
}

KnockdownSignal : AISignalCond
{
	name = "Knockdown";
}

NotBurningSignal : BurningSignal
{
	invert = true;
}

BurningSignal : AISignalCond
{
	name = "Burning";
}

NotPoisonedSignal : PoisonedSignal
{
	invert = true;
}

PoisonedSignal : AISignalCond
{
	name = "Poisoned";
}

NotElectrocutedSignal : ElectrocutedSignal
{
	invert = true;
}

ElectrocutedSignal : AISignalCond
{
	name = "Electrocuted";
}

NotTakedownDefeatSignal : TakedownDefeatSignal
{
	invert = true;
}

TakedownDefeatSignal : AISignalCond
{
	name = "takedown_defeat";
}

ShootingSignal : AISignalCond
{
	name = "ShootingSignal";
}

NotIsEnteringOrLeavingCover : AIGoToCoverCond
{
	isEnteringOrLeavingCover = 0;
}

IsEnteringOrLeavingCover : AIGoToCoverCond
{
	isEnteringOrLeavingCover = 1;
}

NotIsEnteringCover : IsEnteringCover
{
	invert = true;
}

IsEnteringCover : AIGoToCoverCond
{
	isEnteringOrLeavingCover = 2;
}

NotInCover : AIGoToCoverCond
{
	desiredCover = "AIActionTarget.CurrentCover";
	isCoverSelected = 0;
}

InCover : AIGoToCoverCond
{
	desiredCover = "AIActionTarget.CurrentCover";
	isCoverSelected = 1;
}

TargetNotInCover : TargetInCover
{
	invert = true;
}

TargetInCover : AICoverCond
{
	owner = "AIActionTarget.CombatTarget";
}

NotSelectedCoverChanged : AIGoToCoverCond
{
	desiredCover = "AIActionTarget.CurrentCover";
	desiredCoverChanged = 0;
}

SelectedCoverChanged : AIGoToCoverCond
{
	invert = true;
	desiredCover = "AIActionTarget.CurrentCover";
	desiredCoverChanged = 0;
}

NotDesiredCoverChanged : AIGoToCoverCond
{
	desiredCoverChanged = 0;
}

DesiredCoverChanged : AIGoToCoverCond
{
	desiredCoverChanged = 1;
}

NotIsCoverSelected : AIGoToCoverCond
{
	isCoverSelected = 0;
}

IsCoverSelected : AIGoToCoverCond
{
	isCoverSelected = 1;
}

NotInShootingSpot : InShootingSpot
{
	invert = true;
}

InShootingSpot : AICoverCond
{
	coverType = 0;
}

NotSelectedShootingSpot : SelectedShootingSpot
{
	invert = true;
}

SelectedShootingSpot : AICoverCond
{
	coverType = 0;
	cover = "AIActionTarget.SelectedCover";
}

NotSelectedRegularCover : SelectedRegularCover
{
	invert = true;
}

SelectedRegularCover : AICoverCond
{
	coverType = 1;
	cover = "AIActionTarget.SelectedCover";
}

NotInRegularCover : InRegularCover
{
	invert = true;
}

InRegularCover : AICoverCond
{
	coverType = 1;
}

NotInLowCover : InLowCover
{
	invert = true;
}

InLowCover : AICoverCond
{
	coverType = 2;
}

InHighCover : AICoverCond
{
	coverType = 3;
}

NotCoverIsOwnerExposed : AICoverCond
{
	isOwnerExposed = 0;
}

CoverIsOwnerExposed : AICoverCond
{
	isOwnerExposed = 1;
}

NotCommandCoverIsProtectingHorizontallyAgainstTarget : AICoverCond
{
	isProtectingHorizontallyAgainstTarget = 0;
	cover = "AIActionTarget.CommandCover";
	target = "AIActionTarget.CombatTarget";
}

CommandCoverIsProtectingHorizontallyAgainstTarget : AICoverCond
{
	isProtectingHorizontallyAgainstTarget = 1;
	cover = "AIActionTarget.CommandCover";
	target = "AIActionTarget.CombatTarget";
}

NotCoverIsProtectingHorizontallyAgainstTarget : AICoverCond
{
	isProtectingHorizontallyAgainstTarget = 0;
	target = "AIActionTarget.CombatTarget";
}

CoverIsProtectingHorizontallyAgainstTarget : AICoverCond
{
	isProtectingHorizontallyAgainstTarget = 1;
	target = "AIActionTarget.CombatTarget";
}

NotSelectedCoverIsProtectingHorizontallyAgainstTarget : SelectedCoverIsProtectingHorizontallyAgainstTarget
{
	invert = true;
}

SelectedCoverIsProtectingHorizontallyAgainstTarget : AICoverCond
{
	isProtectingHorizontallyAgainstTarget = 1;
	cover = "AIActionTarget.SelectedCover";
	target = "AIActionTarget.CombatTarget";
}

CheckAnyLastAvailableExposureMethods : AICoverCond
{
	hasAnyLastAvailableExposureMethods = 1;
}

CheckNotAnyLastAvailableExposureMethods : AICoverCond
{
	hasAnyLastAvailableExposureMethods = 0;
}

CheckChosenExposureMethodNone : CheckChosenExposureMethodAll
{
	invert = true;
}

CheckChosenExposureMethodAll : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Standing_Step_Left", "Standing_Step_Right", "Standing_Lean_Left", "Standing_Lean_Right", "Crouching_Step_Left", "Crouching_Step_Right", "Crouching_Lean_Left", "Crouching_Lean_Right", "Lean_Over", "Stand_Up", "Standing_Blind_Left", "Standing_Blind_Right", "Crouching_Blind_Left", "Crouching_Blind_Right", "Crouching_Blind_Top"
	];
}

CheckChosenExposureMethodLow : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Crouching_Step_Left", "Crouching_Step_Right", "Crouching_Lean_Left", "Crouching_Lean_Right", "Lean_Over", "Stand_Up", "Crouching_Blind_Left", "Crouching_Blind_Right", "Crouching_Blind_Top"
	];
}

CheckChosenExposureMethodBlind : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Crouching_Blind_Left", "Crouching_Blind_Right", "Crouching_Blind_Top", "Standing_Blind_Left", "Standing_Blind_Right"
	];
}

CheckChosenExposureMethodLowBlind : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Crouching_Blind_Left", "Crouching_Blind_Right", "Crouching_Blind_Top"
	];
}

CheckChosenExposureMethodLowStepOut : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Crouching_Step_Left", "Crouching_Step_Right"
	];
}

CheckChosenExposureMethodLowStepOutStandUp : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Crouching_Step_Left", "Crouching_Step_Right", "Stand_Up"
	];
}

CheckChosenExposureMethodLowLean : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Crouching_Lean_Left", "Crouching_Lean_Right", "Lean_Over"
	];
}

CheckChosenExposureMethodLowStandUp : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Stand_Up"
	];
}

CheckChosenExposureMethodHigh : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Standing_Step_Left", "Standing_Step_Right", "Standing_Lean_Left", "Standing_Lean_Right"
	];
}

CheckChosenExposureMethodHighBlind : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Standing_Blind_Left", "Standing_Blind_Right"
	];
}

CheckChosenExposureMethodHighLean : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Standing_Lean_Left", "Standing_Lean_Right"
	];
}

CheckChosenExposureMethodHighStepOut : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Standing_Step_Left", "Standing_Step_Right"
	];
}

CheckChosenExposureMethodStepOut : AICoverCond
{
	checkChosenExposureMethod = 
	[
		"Standing_Step_Left", "Standing_Step_Right", "Stand_Up"
	];
}

NotIsUsingOffMeshLink : AIActionOR
{
	OR = 
	[
		{
			isUsingOffMeshLink = 0;
		} : AIMovementCond, 
		"Condition.DoorOffMeshLink"
	];
}

IsUsingOffMeshLink : AIMovementCond
{
	isUsingOffMeshLink = 1;
}

NotLineOfSightFailed : AIMovementCond
{
	lineOfSightFailed = 0;
}

LineOfSightFailed : AIMovementCond
{
	lineOfSightFailed = 1;
}

NotConstrainedByRestrictedArea : AIMovementCond
{
	constrainedByRestrictedArea = 0;
}

ConstrainedByRestrictedArea : AIMovementCond
{
	constrainedByRestrictedArea = 1;
}

NotPathFindingFailed : AIMovementCond
{
	pathFindingFailed = 0;
}

PathFindingFailed : AIMovementCond
{
	pathFindingFailed = 1;
}

NotMovementIsEvaluated : AIMovementCond
{
	isEvaluated = 0;
}

MovementIsEvaluated : AIMovementCond
{
	isEvaluated = 1;
}

NotDestinationCalculated : AIMovementCond
{
	isDestinationCalculated = 0;
}

DestinationCalculated : AIMovementCond
{
	isDestinationCalculated = 1;
}

NotDestinationChanged : AIMovementCond
{
	isDestinationChanged = 0;
}

DestinationChanged : AIMovementCond
{
	isDestinationChanged = 1;
}

NotDistanceToDestination0 : AIMovementCond
{
	distanceToDestination = ( 0.1f, -1.f );
}

DistanceToDestination0 : AIMovementCond
{
	distanceToDestination = ( -1.f, 0.1f );
}

DistanceToDestinationAbove1m : AIMovementCond
{
	distanceToDestination = ( 1.f, -1.f );
}

DistanceToDestinationBelow1m : AIMovementCond
{
	distanceToDestination = ( -1.f, 1.f );
}

DistanceToDestinationAbove5m : AIMovementCond
{
	distanceToDestination = ( 5.f, -1.f );
}

DistanceToDestinationBelow5m : AIMovementCond
{
	distanceToDestination = ( -1.f, 5.f );
}

DistanceToDestinationAbove10m : AIMovementCond
{
	distanceToDestination = ( 10.f, -1.f );
}

DistanceToDestinationFriendlyTargetAbove20m : AIMovementCond
{
	destination = "AIActionTarget.FriendlyTarget";
	distanceToDestination = ( 10.f, 9999.f );
}

NotTargetIsMoving : AIMovementCond
{
	isMoving = 0;
}

TargetIsMoving : AIMovementCond
{
	isMoving = 1;
}

NotIsMoving : AIMovementCond
{
	isMoving = 0;
}

IsMoving : AIMovementCond
{
	isMoving = 1;
}

NotIsPauseByDynamicCollision : AIMovementCond
{
	isPauseByDynamicCollision = 0;
}

IsPauseByDynamicCollision : AIMovementCond
{
	isPauseByDynamicCollision = 1;
}

NotLadderOffMeshLink : LadderOffMeshLink
{
	invert = true;
}

LadderOffMeshLink : AIMovementCond
{
	offMeshLinkType = "Ladder";
}

NotDoorOffMeshLink : DoorOffMeshLink
{
	invert = true;
}

DoorOffMeshLink : AIMovementCond
{
	offMeshLinkType = "Door";
}

NotSprint : AIActionOR
{
	OR = 
	[
		{
			invert = true;
			movementType = "Sprint";
		} : AIMovementCond, 
		{
			moveLocomotionAction = "Stop";
		} : AIMovementCond
	];
}

Sprint : AIActionAND
{
	AND = 
	[
		{
			movementType = "Sprint";
		} : AIMovementCond, 
		{
			invert = true;
			moveLocomotionAction = "Stop";
		} : AIMovementCond
	];
}

EvaluatedReachedDestination0dot5 : AIMovementCond
{
	distanceToDestination = ( -1.f, 0.5f );
	isEvaluated = 1;
}

EvaluatedReachedDestination2m : AIMovementCond
{
	distanceToDestination = ( -1.f, 2.f );
	isEvaluated = 1;
}

EvaluatedReachedDestination4m : AIMovementCond
{
	distanceToDestination = ( -1.f, 4.f );
	isEvaluated = 1;
}

EvaluatedPathFinding : AIMovementCond
{
	pathFindingFailed = 0;
	isEvaluated = 1;
}

AmmoCount0 : AIActionOR
{
	OR = 
	[
		{
			invert = true;
			weaponSlot = "AttachmentSlots.WeaponRight";
			min = 1;
		} : AIAmmoCountCond, 
		{
			invert = true;
			weaponSlot = "AttachmentSlots.WeaponLeft";
			min = 1;
		} : AIAmmoCountCond
	];
}

AmmoCountMin1 : AIActionOR
{
	OR = 
	[
		{
			weaponSlot = "AttachmentSlots.WeaponRight";
			min = 1;
		} : AIAmmoCountCond, 
		{
			weaponSlot = "AttachmentSlots.WeaponLeft";
			min = 1;
		} : AIAmmoCountCond
	];
}

AmmoCountAboveHalf : AIActionOR
{
	OR = 
	[
		{
			weaponSlot = "AttachmentSlots.WeaponRight";
			percentage = ( 0.49f, -1.f );
		} : AIAmmoCountCond, 
		{
			weaponSlot = "AttachmentSlots.WeaponLeft";
			percentage = ( 0.49f, -1.f );
		} : AIAmmoCountCond
	];
}

AmmoCountBelowHalf : AIActionOR
{
	OR = 
	[
		{
			weaponSlot = "AttachmentSlots.WeaponRight";
			percentage = ( -1.f, 0.49f );
		} : AIAmmoCountCond, 
		{
			weaponSlot = "AttachmentSlots.WeaponLeft";
			percentage = ( -1.f, 0.49f );
		} : AIAmmoCountCond
	];
}

AmmoCountBelow75perf : AIActionOR
{
	OR = 
	[
		{
			weaponSlot = "AttachmentSlots.WeaponRight";
			percentage = ( -1.f, 0.75f );
		} : AIAmmoCountCond, 
		{
			weaponSlot = "AttachmentSlots.WeaponLeft";
			percentage = ( -1.f, 0.75f );
		} : AIAmmoCountCond
	];
}

AmmoCountFull : AIActionOR
{
	OR = 
	[
		{
			weaponSlot = "AttachmentSlots.WeaponRight";
			percentage = ( 1.f, -1.f );
		} : AIAmmoCountCond, 
		{
			weaponSlot = "AttachmentSlots.WeaponLeft";
			percentage = ( 1.f, -1.f );
		} : AIAmmoCountCond
	];
}

NotCalculatePathStraightFullCheckLeftClose : AICalculatePathCond
{
	invert = true;
	distance = 1.5f;
	directionAngle = 270.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

CalculatePathStraightFullCheckLeftClose : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 270.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightForwardClose : AICalculatePathCond
{
	invert = true;
	distance = 1.5f;
	directionAngle = 0.f;
	checkStraightPath = true;
}

CalculatePathStraightForwardClose : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 0.f;
	checkStraightPath = true;
}

NotCalculatePathStraightFullCheckForwardClose : CalculatePathStraightFullCheckForwardClose
{
	invert = true;
}

CalculatePathStraightFullCheckForwardClose : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 0.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightFullCheckForwardKurt : CalculatePathStraightFullCheckForwardKurt
{
	invert = true;
}

CalculatePathStraightFullCheckForwardKurt : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 0.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightFullCheckForwardKurtShort : CalculatePathStraightFullCheckForwardKurt
{
	invert = true;
}

CalculatePathStraightFullCheckForwardKurtShort : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 0.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
	startPositionOffset = ( 0.f, 0.f, -0.25f );
}

NotCalculatePathStraightForward4m : CalculatePathStraightForward4m
{
	invert = true;
}

CalculatePathStraightForward4m : AICalculatePathCond
{
	distance = 4.f;
	directionAngle = 0.f;
	checkStraightPath = true;
}

NotCalculatePathStraightLeftClose : AICalculatePathCond
{
	invert = true;
	distance = 1.5f;
	directionAngle = 270.f;
	checkStraightPath = true;
}

CalculatePathStraightLeftClose : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 270.f;
	checkStraightPath = true;
}

NotCalculatePathStraightFullCheckFrontLeftClose : AICalculatePathCond
{
	invert = true;
	distance = 1.5f;
	directionAngle = 315.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

CalculatePathStraightFullCheckFrontLeftClose : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 315.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightFullCheckRightClose : AICalculatePathCond
{
	invert = true;
	distance = 1.5f;
	directionAngle = 90.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

CalculatePathStraightFullCheckRightClose : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 90.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightRightClose : AICalculatePathCond
{
	invert = true;
	distance = 1.5f;
	directionAngle = 90.f;
	checkStraightPath = true;
}

CalculatePathStraightRightClose : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 90.f;
	checkStraightPath = true;
}

NotCalculatePathStraightFullCheckBackClose : AICalculatePathCond
{
	invert = true;
	distance = 1.5f;
	directionAngle = 180.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

CalculatePathStraightFullCheckBackClose : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 180.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightBackClose : AICalculatePathCond
{
	invert = true;
	distance = 1.5f;
	directionAngle = 180.f;
	checkStraightPath = true;
}

CalculatePathStraightBackClose : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 180.f;
	checkStraightPath = true;
}

NotCalculatePathStraightBack4m : CalculatePathStraightBack4m
{
	invert = true;
}

CalculatePathStraightBack4m : AICalculatePathCond
{
	distance = 4.f;
	directionAngle = 180.f;
	checkStraightPath = true;
}

NotCalculatePathStraightBack10m : CalculatePathStraightBack10m
{
	invert = true;
}

CalculatePathStraightBack10m : AICalculatePathCond
{
	distance = 10.f;
	directionAngle = 180.f;
	checkStraightPath = true;
}

NotCalculatePathStraightFullCheckForward1dot5m : CalculatePathStraightFullCheckForward1dot5m
{
	invert = true;
}

CalculatePathStraightFullCheckForward1dot5m : AICalculatePathCond
{
	distance = 1.f;
	directionAngle = 0.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightFullCheckBack1dot5m : CalculatePathStraightFullCheckBack1dot5m
{
	invert = true;
}

CalculatePathStraightFullCheckBack1dot5m : AICalculatePathCond
{
	distance = 1.f;
	directionAngle = 180.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightFullCheckFrontRightClose : AICalculatePathCond
{
	invert = true;
	distance = 1.5f;
	directionAngle = 45.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

CalculatePathStraightFullCheckFrontRightClose : AICalculatePathCond
{
	distance = 2.f;
	directionAngle = 45.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightFullCheckLeft1dot5m : CalculatePathStraightFullCheckLeft1dot5m
{
	invert = true;
}

CalculatePathStraightFullCheckLeft1dot5m : AICalculatePathCond
{
	distance = 1.f;
	directionAngle = 270.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightFullCheckRight1dot5m : CalculatePathStraightFullCheckRight1dot5m
{
	invert = true;
}

CalculatePathStraightFullCheckRight1dot5m : AICalculatePathCond
{
	distance = 1.f;
	directionAngle = 90.f;
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightLeftVeryClose : CalculatePathStraightLeftVeryClose
{
	invert = true;
}

CalculatePathStraightLeftVeryClose : AICalculatePathCond
{
	distance = 0.25f;
	directionAngle = 270.f;
	checkStraightPath = true;
}

NotCalculatePathStraightRightVeryClose : CalculatePathStraightRightVeryClose
{
	invert = true;
}

CalculatePathStraightRightVeryClose : AICalculatePathCond
{
	distance = 0.25f;
	directionAngle = 90.f;
	checkStraightPath = true;
}

NotCalculatePathStraightToTarget10mForwardOffset : CalculatePathStraightToTarget10mForwardOffset
{
	invert = true;
}

CalculatePathStraightToTarget10mForwardOffset : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
	checkStraightPath = true;
	startPositionOffset = ( 0.f, 10.f, 0.f );
}

NotCalculatePathStraightToTarget1mBack : CalculatePathStraightToTarget1mBack
{
	invert = true;
}

CalculatePathStraightToTarget1mBack : AICalculatePathCond
{
	distance = 1.f;
	directionAngle = 180.f;
	checkStraightPath = true;
}

NotCalculatePathStraightFullCheckToItem : CalculatePathStraightFullCheckToItem
{
	invert = true;
}

CalculatePathStraightFullCheckToItem : AICalculatePathCond
{
	target = "AIActionTarget.TargetItem";
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightFullCheckToTarget : CalculatePathStraightFullCheckToTarget
{
	invert = true;
}

CalculatePathStraightFullCheckToTarget : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
	checkStraightPath = true;
	checkDynamicObstacle = true;
}

NotCalculatePathStraightToTarget : CalculatePathStraightToTarget
{
	invert = true;
}

CalculatePathStraightToTarget : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
	checkStraightPath = true;
}

NotCalculatePathStraightToTarget1mTolerance : CalculatePathStraightToTarget1mTolerance
{
	invert = true;
}

CalculatePathStraightToTarget1mTolerance : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
	checkStraightPath = true;
	tolerance = 1.f;
}

NotCalculatePathStraightToTarget0dot1mZOffset : CalculatePathStraightToTarget0dot1mZOffset
{
	invert = true;
}

CalculatePathStraightToTarget0dot1mZOffset : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
	checkStraightPath = true;
	startPositionOffset = ( 0.f, 0.f, 0.1f );
}

NotCalculatePathStraightToTargetItem : CalculatePathStraightToTargetItem
{
	invert = true;
}

CalculatePathStraightToTargetItem : AICalculatePathCond
{
	target = "AIActionTarget.TargetItem";
	checkStraightPath = true;
}

NotCalculatePathStraightToTargetItem1mTolerance : CalculatePathStraightToTargetItem1mTolerance
{
	invert = true;
}

CalculatePathStraightToTargetItem1mTolerance : AICalculatePathCond
{
	target = "AIActionTarget.TargetItem";
	checkStraightPath = true;
	tolerance = 1.f;
}

NotCalculatePathStraightFullCheckToTarget1dot5mUpwardOffset : CalculatePathStraightFullCheckToTarget1dot5mUpwardOffset
{
	invert = true;
}

CalculatePathStraightFullCheckToTarget1dot5mUpwardOffset : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
	checkStraightPath = true;
	checkDynamicObstacle = true;
	startPositionOffset = ( 0.f, 0.f, 1.5f );
}

NotCalculatePathToTarget : CalculatePathToTarget
{
	invert = true;
}

CalculatePathToTarget : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
}

NotCalculatePathToTargetItem : CalculatePathToTargetItem
{
	invert = true;
}

CalculatePathToTargetItem : AICalculatePathCond
{
	target = "AIActionTarget.TargetItem";
}

NotCalculatePathToTargetSmasherJump : CalculatePathToTargetSmasherJump
{
	invert = true;
}

CalculatePathToTargetSmasherJump : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
	allowedOffMeshTags = 
	[
		"SmasherJump"
	];
}

NotCalculatePathToTargetOdaJump : CalculatePathToTargetOdaJump
{
	invert = true;
}

CalculatePathToTargetOdaJump : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
	allowedOffMeshTags = 
	[
		"OdaJump"
	];
}

NotCalculatePathToTarget1mTolerance : CalculatePathToTarget1mTolerance
{
	invert = true;
}

CalculatePathToTarget1mTolerance : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
	tolerance = 1.f;
}

NotCalculatePathToFollower : CalculatePathToFollower
{
	invert = true;
}

CalculatePathToFollower : AICalculatePathCond
{
	target = "AIActionTarget.FriendlyTarget";
}

NotCalculatePathToMovementDestination : CalculatePathToMovementDestination
{
	invert = true;
}

CalculatePathToMovementDestination : AICalculatePathCond
{
	target = "AIActionTarget.MovementDestination";
}

CalculatePathStraight1m : AICalculatePathCond
{
	distance = 1.f;
	checkStraightPath = true;
}

CalculatePathStraight5m : AICalculatePathCond
{
	distance = 5.f;
	checkStraightPath = true;
}

NotCalculatePathStraight5m : CalculatePathStraight5m
{
	invert = true;
}

CalculatePathStraight3m : AICalculatePathCond
{
	distance = 3.f;
	checkStraightPath = true;
}

CalculatePathStraight5m180deg : AICalculatePathCond
{
	checkStraightPath = true;
	distance = 5.f;
	directionAngle = 180.f;
}

CalculatePathStraight3m180deg : AICalculatePathCond
{
	checkStraightPath = true;
	distance = 3.f;
	directionAngle = 180.f;
}

NotCalculatePathToStimSource : CalculatePathToStimSource
{
	invert = true;
}

CalculatePathToStimSource : AICalculatePathCond
{
	target = "AIActionTarget.StimSource";
}

NotCalculatePathToStimTarget : CalculatePathToStimTarget
{
	invert = true;
}

CalculatePathToStimTarget : AICalculatePathCond
{
	target = "AIActionTarget.StimTarget";
}

CalculatePathToCustomWorldPosition : AICalculatePathCond
{
	target = "AIActionTarget.CustomWorldPosition";
}

CalculatePathToOut_LastChasePosition : AICalculatePathCond
{
	target = "AIActionTarget.Out_LastChasePosition";
}

NotCalculatePathToOut_LastChasePosition : CalculatePathToOut_LastChasePosition
{
	invert = true;
}

NotCalculateStraightPathToTarget : CalculateStraightPathToTarget
{
	invert = true;
}

CalculateStraightPathToTarget : AICalculatePathCond
{
	target = "AIActionTarget.CombatTarget";
	checkStraightPath = true;
}

CalculatePathToOut_SearchPosition : AICalculatePathCond
{
	target = "AIActionTarget.Out_SearchPosition";
}

CalculatePathToIn_LastKnownPosition : AICalculatePathCond
{
	target = "AIActionTarget.In_LastKnownPosition";
}

CalculatePathToPlayer : AICalculatePathCond
{
	target = "AIActionTarget.Player";
}

NotCalculatePathToPlayer : CalculatePathToPlayer
{
	invert = true;
}

CalculatePathToOwner : AICalculatePathCond
{
	target = "AIActionTarget.Owner";
}

NotCalculatePathToOwner : AICalculatePathCond
{
	target = "AIActionTarget.Owner";
	invert = true;
}

NotMovePolicyCooldown : Condition.MovePolicyCooldown
{
	invert = true;
}

MovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.MovePolicyCooldown"
	];
}

NotAvoidLOSMovePolicyCooldown : Condition.AvoidLOSMovePolicyCooldown
{
	invert = true;
}

AvoidLOSMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.AvoidLOSMovePolicyCooldown"
	];
}

WaitForItemSpawnCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "WaitForItemSpawnCooldown";
		}
	];
}

SwitchStatesCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "SwitchStates";
		}
	];
}

SwitchWeaponCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "SwitchWeapon";
		}
	];
}

SpecialActionPeekCooldown : AICooldownCond
{
	cooldowns = 
	[
		"CommandHandlerActions.SpecialActionPeekCooldown"
	];
}

SpecialActionGoCooldown : AICooldownCond
{
	cooldowns = 
	[
		"CommandHandlerActions.SpecialActionGoCooldown"
	];
}

MeleeTicketExpiration : AICooldownCond
{
	cooldowns = 
	[
		"CombatDecorator.MeleeTicketExpiration"
	];
}

TeleportToFollowerCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "TeleportToFollower";
		}
	];
}

NotPushAttackCooldown : PushAttackCooldown
{
	invert = true;
}

PushAttackCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "PushAttack";
		}
	];
}

NotRMAMovePolicyCooldown : Condition.RMAMovePolicyCooldown
{
	invert = true;
}

RMAMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.RMAMovePolicyCooldown"
	];
}

NotRMAMovePolicyMediumCooldown : Condition.RMAMovePolicyMediumCooldown
{
	invert = true;
}

RMAMovePolicyMediumCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.RMAMovePolicyMediumCooldown"
	];
}

NotPathMovePolicyLongCooldown : Condition.PathMovePolicyLongCooldown
{
	invert = true;
}

PathMovePolicyLongCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.PathMovePolicyLongCooldown"
	];
}

AvoidLOSSprintCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.AvoidLOSSprintCooldown"
	];
}

PathMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.PathMovePolicyCooldown"
	];
}

PauseByDynamicCollisionCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.PauseByDynamicCollisionCooldown"
	];
}

SprintHarassCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.SprintHarassCooldown"
	];
}

CoverBehaviorAfterCatchupCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.CoverBehaviorAfterCatchupCooldown"
	];
}

DefaultRingPathMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "DefaultRingPathMovePolicy";
		} : MovementActions.PathMovePolicyCooldown
	];
}

MeleeRingPathMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "MeleeRingPathMovePolicy";
		} : MovementActions.PathMovePolicyCooldown
	];
}

CloseRingPathMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "CloseRingPathMovePolicy";
		} : MovementActions.PathMovePolicyCooldown
	];
}

CloseRingLOSMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "CloseRingLOSMovePolicy";
		} : MovementActions.PathMovePolicyCooldown
	];
}

MediumRingPathMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "MediumRingPathMovePolicy";
		} : MovementActions.PathMovePolicyCooldown
	];
}

MediumRingLOSMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "MediumRingLOSMovePolicy";
		} : MovementActions.PathMovePolicyCooldown
	];
}

FarRingPathMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "FarRingPathMovePolicy";
		} : MovementActions.PathMovePolicyCooldown
	];
}

FarRingLOSMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "FarRingLOSMovePolicy";
		} : MovementActions.PathMovePolicyCooldown
	];
}

ExtremeRingPathMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "ExtremeRingPathMovePolicy";
		} : MovementActions.PathMovePolicyCooldown
	];
}

ExtremeRingLOSMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "ExtremeRingLOSMovePolicy";
		} : MovementActions.PathMovePolicyCooldown
	];
}

SimpleMeleeCombatCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "SimpleMeleeCombat";
		} : AIActionCooldown
	];
}

SimpleMeleeTauntCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "SimpleMeleeTaunt";
		} : AIActionCooldown
	];
}

HitMovePolicyCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.HitMovePolicyCooldown"
	];
}

NotShootingSpotSelectionCooldown : Condition.ShootingSpotSelectionCooldown
{
	invert = true;
}

ShootingSpotSelectionCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "ShootingSpotSelection";
		} : AIActionCooldown
	];
}

NotInitialCatchUpCooldown : Condition.InitialCatchUpCooldown
{
	invert = true;
}

InitialCatchUpCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.InitialCatchUpCooldown"
	];
}

NotCatchupDistanceDestinationReachedCooldown : Condition.CatchupDistanceDestinationReachedCooldown
{
	invert = true;
}

CatchupDistanceDestinationReachedCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.CatchupDistanceDestinationReachedCooldown"
	];
}

NotCrouchShootCooldown : InitialCrouchShootCooldown
{
	invert = true;
}

InitialCrouchShootCooldown : AICooldownCond
{
	cooldowns = 
	[
		"ShootActions.CrouchShootCooldown"
	];
}

InitThrowGrenadeCooldown : AICooldownCond
{
	cooldowns = 
	[
		"ItemHandling.InitThrowGrenadeCooldown"
	];
}

VehicleUnmountCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "VehicleUnmount";
		}
	];
}

HackAppliedCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "HackApplied";
		}
	];
}

NotMeleeDefenseCooldown : Condition.MeleeDefenseCooldown
{
	invert = true;
}

MeleeDefenseCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "MeleeDefenseCooldown";
		}
	];
}

SyncCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "Sync";
		}
	];
}

WoundedShootCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "WoundedShoot";
		}
	];
}

ReloadCooldown : AICooldownCond
{
	cooldowns = 
	[
		"ItemHandling.ReloadCooldown"
	];
}

NotStrafeCooldownHit : Condition.StrafeCooldownHit
{
	invert = true;
}

StrafeCooldownHit : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.StrafeCooldownHit"
	];
}

NotStrafeEvadeCooldown : Condition.StrafeEvadeCooldown
{
	invert = true;
}

StrafeEvadeCooldown : AICooldownCond
{
	cooldowns = 
	[
		"MovementActions.StrafeEvadeCooldown"
	];
}

GrenadeDodgeCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "GrenadeDodgeCooldown";
		}
	];
}

ContactDodgeCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "DodgeMeleeContactCooldown";
		}
	];
}

DodgeCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "Dodge";
		}
	];
}

LineOfSightDodgeCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "OutOfLineOfSightDodge";
		}
	];
}

GuardBreakCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "GuardBreak";
		}
	];
}

MeleeDodgeCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "MeleeDodge";
		}
	];
}

HitDodgeCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "DodgeCooldown";
		}
	];
}

DodgeAfterHitReactionCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "DodgeAfterHitReaction";
		}
	];
}

NotDroneCatchUpCooldown : DroneCatchUpCooldown
{
	invert = true;
}

DroneCatchUpCooldown : AICooldownCond
{
	cooldowns = 
	[
		"DroneActions.CatchUpCooldown"
	];
}

NotDroneCatchUpFarCooldown : DroneCatchUpFarCooldown
{
	invert = true;
}

DroneCatchUpFarCooldown : AICooldownCond
{
	cooldowns = 
	[
		"DroneActions.CatchUpFarCooldown"
	];
}

NotDroneCatchUpFallbackProcedureCooldown : DroneCatchUpFallbackProcedureCooldown
{
	invert = true;
}

DroneCatchUpFallbackProcedureCooldown : AICooldownCond
{
	cooldowns = 
	[
		"DroneActions.CatchUpFallbackProcedureCooldown"
	];
}

NotDroneGriffinShootCooldown : DroneGriffinShootCooldown
{
	invert = true;
}

DroneGriffinShootCooldown : AICooldownCond
{
	cooldowns = 
	[
		"DroneGriffinActions.ShootCooldown"
	];
}

OdaBossDashBackCooldownCooldown : AICooldownCond
{
	cooldowns = 
	[
		"OdaBoss.DashBackCooldown"
	];
}

AnimalsBossThrowHammerCooldown : AICooldownCond
{
	cooldowns = 
	[
		"AnimalsBoss.ThrowHammerCooldown"
	];
}

AnimalsBossDashAttackCooldown : AICooldownCond
{
	cooldowns = 
	[
		"AnimalsBoss.ThrowHammerCooldown"
	];
}

AnimalsBossMeleeComboCooldown : AICooldownCond
{
	cooldowns = 
	[
		"AnimalsBoss.ThrowHammerCooldown"
	];
}

SandevistanDashLeftCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "SandevistanDashLeft";
		}
	];
}

SandevistanDashRightCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "SandevistanDashRight";
		}
	];
}

NotBlockStateCooldown : BlockStateCooldown
{
	invert = true;
}

BlockStateCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "BlockStateCooldown";
		}
	];
}

ParryStateCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "ParryStateCooldown";
		}
	];
}

CerberusEscapeOpportunityCooldown : AICooldownCond
{
	cooldowns = 
	[
		{
			name = "CerberusEscapeOpportunityCooldown";
		}
	];
}

NotCerberusEscapeOpportunityCooldown : CerberusEscapeOpportunityCooldown
{
	invert = true;
}

WeaponChangedCooldown : AICooldownCond
{
	cooldowns = 
	[
		"ShootActions.WeaponChangedCooldown"
	];
}

NotWeaponChangedCooldown : WeaponChangedCooldown
{
	invert = true;
}

NotHitTimeout0dot7 : HitTimeout0dot7
{
	invert = true;
}

HitTimeout0dot7 : AIHitCond
{
	hitTimeout = 0.7f;
}

NotHitTimeout0dot7MinSeverity1 : HitTimeout0dot7MinSeverity1
{
	invert = true;
}

HitTimeout0dot7MinSeverity1 : AIHitCond
{
	hitTimeout = 0.7f;
	minHitSeverity = 1;
}

NotHitTimeout0dot7MinSeverity2 : HitTimeout0dot7MinSeverity2
{
	invert = true;
}

HitTimeout0dot7MinSeverity2 : AIHitCond
{
	hitTimeout = 0.7f;
	minHitSeverity = 2;
}

NotHitTimeout1 : HitTimeout1
{
	invert = true;
}

HitTimeout1 : AIHitCond
{
	hitTimeout = 1.f;
}

NotHitTimeout3 : HitTimeout3
{
	invert = true;
}

HitTimeout3 : AIHitCond
{
	hitTimeout = 3.f;
}

NotHitCount3Timeout3 : HitCount3Timeout3
{
	invert = true;
}

HitCount3Timeout3 : AIHitCond
{
	hitTimeout = 3.f;
	targetHitCount = 3;
}

HitCount3Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 3;
}

NotHitCount1Timeout1 : HitCount1Timeout1
{
	invert = true;
}

HitCount1Timeout1 : AIHitCond
{
	hitTimeout = 1.f;
	targetHitCount = 1;
}

NotHitCount1Timeout1Smasher : HitCount1Timeout1Smasher
{
	invert = true;
}

HitCount1Timeout1Smasher : AIHitCond
{
	hitTimeout = 0.1f;
	targetHitCount = 1;
}

NotHitCount1Timeout1BulletSmasher : HitCount1Timeout1BulletSmasher
{
	invert = true;
}

HitCount1Timeout1BulletSmasher : AIHitCond
{
	hitTimeout = 0.1f;
	targetHitCount = 1;
	attackTag = "bullet";
}

NotHitCount7Timeout5 : HitCount7Timeout5
{
	invert = true;
}

HitCount7Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 7;
}

NotHitTimeout5 : HitTimeout5
{
	invert = true;
}

HitTimeout5 : AIHitCond
{
	hitTimeout = 5.f;
}

NotHitTimeout7 : HitTimeout7
{
	invert = true;
}

HitTimeout7 : AIHitCond
{
	hitTimeout = 7.f;
}

NotHitTimeout15 : HitTimeout15
{
	invert = true;
}

HitTimeout15 : AIHitCond
{
	hitTimeout = 15.f;
}

NotHitTimeout3MinSeverity0 : HitTimeout3MinSeverity0
{
	invert = true;
}

HitTimeout3MinSeverity0 : AIHitCond
{
	hitTimeout = 3.f;
	minHitSeverity = 0;
}

NotHitTimeout2MinSeverity0 : HitTimeout2MinSeverity0
{
	invert = true;
}

HitTimeout2MinSeverity0 : AIHitCond
{
	hitTimeout = 2.f;
	minHitSeverity = 0;
}

NotHitTimeout2MinSeverity1 : HitTimeout2MinSeverity1
{
	invert = true;
}

HitTimeout2MinSeverity1 : AIHitCond
{
	hitTimeout = 2.f;
	minHitSeverity = 1;
}

NotHitTimeout1dot5MinSeverity1 : HitTimeout1dot5MinSeverity1
{
	invert = true;
}

HitTimeout1dot5MinSeverity1 : AIHitCond
{
	hitTimeout = 1.5f;
	minHitSeverity = 1;
}

NotHitTimeout1MinSeverity0 : HitTimeout1MinSeverity0
{
	invert = true;
}

HitTimeout1MinSeverity0 : AIHitCond
{
	hitTimeout = 1.f;
}

NotHitTimeout1MinSeverity1 : HitTimeout1MinSeverity1
{
	invert = true;
}

HitTimeout1MinSeverity1 : AIHitCond
{
	hitTimeout = 1.f;
	minHitSeverity = 1;
}

NotHitTimeout1MinSeverity1MaxSeverity6 : HitTimeout1MinSeverity1MaxSeverity6
{
	invert = true;
}

HitTimeout1MinSeverity1MaxSeverity6 : AIHitCond
{
	hitTimeout = 1.f;
	minHitSeverity = 1;
	maxHitSeverity = 6;
}

NotHitTimeout3MinSeverity1MaxSeverity6 : AIHitCond
{
	invert = true;
	hitTimeout = 3.f;
	minHitSeverity = 1;
	maxHitSeverity = 6;
}

HitTimeout3MinSeverity1MaxSeverity6 : AIHitCond
{
	hitTimeout = 3.f;
	minHitSeverity = 1;
	maxHitSeverity = 6;
}

NotHitDirectionLeft : HitDirectionLeft
{
	invert = true;
}

HitDirectionLeft : AIHitCond
{
	hitTimeout = 2.f;
	hitDirection = 1;
}

NotHitDirectionRight : HitDirectionRight
{
	invert = true;
}

HitDirectionRight : AIHitCond
{
	hitTimeout = 2.f;
	hitDirection = 3;
}

NotHitTimeout1dot5MinSeverity2 : HitTimeout1dot5MinSeverity2
{
	invert = true;
}

HitTimeout1dot5MinSeverity2 : AIHitCond
{
	hitTimeout = 1.5f;
	minHitSeverity = 2;
}

NotCurrentNetrunnerProxyHitTimeout1Severity3 : CurrentNetrunnerProxyHitTimeout1Severity3
{
	invert = true;
}

CurrentNetrunnerProxyHitTimeout1Severity3 : AIHitCond
{
	hitTimeout = 1.f;
	minHitSeverity = 3;
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

NotCurrentNetrunnerProxyHitCount15Timeout5 : CurrentNetrunnerProxyHitCount15Timeout5
{
	invert = true;
}

CurrentNetrunnerProxyHitCount15Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 15;
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

CurrentNetrunnerProxyHitCount3Timeout3 : AIHitCond
{
	hitTimeout = 3.f;
	targetHitCount = 3;
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

CurrentNetrunnerProxyHitCount3Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 3;
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

NotCurrentNetrunnerProxyHitCount6Timeout5 : CurrentNetrunnerProxyHitCount6Timeout5
{
	invert = true;
}

CurrentNetrunnerProxyHitCount6Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 6;
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

CurrentNetrunnerProxyHitCount2Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 2;
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

CurrentNetrunnerProxyHitCount12Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 12;
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

CurrentNetrunnerProxyHitCount8Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 8;
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

NotHitCount3Timeout5 : HitCount6Timeout5
{
	invert = true;
}

HitCount6Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 6;
}

HitCount8Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 8;
}

HitCount12Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 12;
}

NotHitCount15Timeout5 : HitCount15Timeout5
{
	invert = true;
}

HitCount15Timeout5 : AIHitCond
{
	hitTimeout = 5.f;
	targetHitCount = 15;
}

NotHitTimeout1dot5MinSeverity0 : HitTimeout1dot5MinSeverity0
{
	invert = true;
}

HitTimeout1dot5MinSeverity0 : AIHitCond
{
	hitTimeout = 1.5f;
	minHitSeverity = 0;
}

NotHitTimeout4MinSeverity2 : HitTimeout4MinSeverity2
{
	invert = true;
}

HitTimeout4MinSeverity2 : AIHitCond
{
	hitTimeout = 4.f;
	minHitSeverity = 2;
}

NotHitTimeout4MinSeverity2MaxSeverity6 : HitTimeout4MinSeverity2MaxSeverity6
{
	invert = true;
}

HitTimeout4MinSeverity2MaxSeverity6 : AIHitCond
{
	hitTimeout = 4.f;
	minHitSeverity = 2;
	maxHitSeverity = 6;
}

NotMinAccuracySharedValue1 : MinAccuracySharedValue1
{
	invert = true;
}

MinAccuracySharedValue1 : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	minAccuracySharedValue = 1.0f;
}

NotMinAccuracySharedValue0dot95 : MinAccuracySharedValue0dot95
{
	invert = true;
}

MinAccuracySharedValue0dot95 : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	minAccuracySharedValue = 0.95f;
}

NotMinAccuracySharedValue0dot85 : MinAccuracySharedValue0dot85
{
	invert = true;
}

MinAccuracySharedValue0dot85 : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	minAccuracySharedValue = 0.85f;
}

NotMinAccuracySharedValue0dot5 : MinAccuracySharedValue0dot5
{
	invert = true;
}

MinAccuracySharedValue0dot5 : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	minAccuracySharedValue = 0.5f;
}

NotTopThreatMinAccuracySharedValue0dot5 : TopThreatMinAccuracySharedValue0dot5
{
	invert = true;
}

TopThreatMinAccuracySharedValue0dot5 : AITargetCond
{
	target = "AIActionTarget.TopThreat";
	minAccuracySharedValue = 0.5f;
}

NotTopThreatMinAccuracySharedValue0 : TopThreatMinAccuracySharedValue0
{
	invert = true;
}

TopThreatMinAccuracySharedValue0 : AITargetCond
{
	target = "AIActionTarget.TopThreat";
	minAccuracySharedValue = 0.01f;
}

NotMinAccuracyValue1 : MinAccuracyValue1
{
	invert = true;
}

MinAccuracyValue1 : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	minAccuracyValue = 1.f;
}

NotMinAccuracyValue0dot95 : MinAccuracyValue0dot95
{
	invert = true;
}

MinAccuracyValue0dot95 : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	minAccuracyValue = 0.95f;
}

NotMinAccuracyValue0dot85 : MinAccuracyValue0dot85
{
	invert = true;
}

MinAccuracyValue0dot85 : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	minAccuracyValue = 0.85f;
}

NotMinAccuracyValue0dot66 : MinAccuracyValue0dot66
{
	invert = true;
}

MinAccuracyValue0dot66 : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	minAccuracyValue = 0.66f;
}

NotMinAccuracyValue0dot33 : MinAccuracyValue0dot33
{
	invert = true;
}

MinAccuracyValue0dot33 : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	minAccuracyValue = 0.33f;
}

NotMinAccuracyValue0 : MinAccuracyValue0
{
	invert = true;
}

MinAccuracyValue0 : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	minAccuracyValue = 0.001f;
}

NotStimTargetMinAccuracyValue0 : StimTargetMinAccuracyValue0
{
	invert = true;
}

StimTargetMinAccuracyValue0 : AITargetCond
{
	target = "AIActionTarget.StimTarget";
	minAccuracyValue = 0.001f;
}

NotPlayerMinAccuracyValue0 : PlayerMinAccuracyValue0
{
	invert = true;
}

PlayerMinAccuracyValue0 : AITargetCond
{
	target = "AIActionTarget.Player";
	minAccuracyValue = 0.001f;
}

NotTargetIsVisible : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	isVisible = 0;
}

TargetIsVisible : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	isVisible = 1;
}

NotTargetIsActive : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	isActive = 0;
}

TargetIsActive : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	isActive = 1;
}

NotTargetIsAlive : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	isAlive = 0;
}

TargetIsAlive : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	isAlive = 1;
}

NotStimTargetIsVisible : AITargetCond
{
	target = "AIActionTarget.StimTarget";
	isVisible = 0;
}

StimTargetIsVisible : AITargetCond
{
	target = "AIActionTarget.StimTarget";
	isVisible = 1;
}

StimTargetIsActive : AITargetCond
{
	target = "AIActionTarget.StimTarget";
	isActive = 1;
}

StimTargetMinDetectionValue0 : AITargetCond
{
	target = "AIActionTarget.StimTarget";
	minDetectionValue = 0.f;
}

StimTargetMinDetectionValue1 : AITargetCond
{
	target = "AIActionTarget.StimTarget";
	minDetectionValue = 1.f;
}

StimTargetMaxDetectionValue90 : AITargetCond
{
	target = "AIActionTarget.StimTarget";
	minDetectionValue = 0.90f;
	invert = true;
}

PlayerDetectedVisibleActive : AITargetCond
{
	target = "AIActionTarget.Player";
	minDetectionValue = 1.0f;
	isActive = 1;
	isVisible = 1;
}

StimTargetFullyDetected : AITargetCond
{
	target = "AIActionTarget.StimTarget";
	minDetectionValue = 1.0f;
	isActive = 1;
}

NotNearestSquadmateIsVisible : AITargetCond
{
	target = "AIActionTarget.NearestSquadmate";
	isVisible = 0;
}

NearestSquadmateIsVisible : AITargetCond
{
	target = "AIActionTarget.NearestSquadmate";
	isVisible = 1;
}

NearestSquadmateNotHuman : AINPCTypeCond
{
	target = "AIActionTarget.NearestSquadmate";
	invert = true;
	allowedNPCTypes = 
	[
		"NPCType.Human"
	];
}

NotTargetInvalidExpectation : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	invalidExpectation = 0;
}

TargetInvalidExpectation : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	invalidExpectation = 1;
}

NotMaxVisibilityToTargetDistanceChest3m : MaxVisibilityToTargetDistanceChest3m
{
	invert = true;
}

MaxVisibilityToTargetDistanceChest3m : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	maxVisibilityToTargetDistance = 3.f;
	isCombatTargetVisibleFrom = "AIAdditionalTraceType.Chest";
}

NotMaxVisibilityToTargetDistanceHip3m : MaxVisibilityToTargetDistanceHip3m
{
	invert = true;
}

MaxVisibilityToTargetDistanceHip3m : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	maxVisibilityToTargetDistance = 3.f;
	isCombatTargetVisibleFrom = "AIAdditionalTraceType.Hip";
}

NotMaxVisibilityToTargetDistance3m : MaxVisibilityToTargetDistance3m
{
	invert = true;
}

MaxVisibilityToTargetDistance3m : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	maxVisibilityToTargetDistance = 3.f;
}

NotMaxVisibilityToTargetRealPositionDistance3m : MaxVisibilityToTargetRealPositionDistance3m
{
	invert = true;
}

MaxVisibilityToTargetRealPositionDistance3m : AITargetCond
{
	target = "VehicleActions.CombatTarget";
	maxVisibilityToTargetDistance = 3.f;
}

NotMaxVisibilityToTopThreatDistance3m : MaxVisibilityToTopThreatDistance3m
{
	invert = true;
}

MaxVisibilityToTopThreatDistance3m : AITargetCond
{
	target = "AIActionTarget.TopThreat";
	maxVisibilityToTargetDistance = 3.f;
}

NotMaxVisibilityToTargetDistance1dot5m : MaxVisibilityToTargetDistance1dot5m
{
	invert = true;
}

MaxVisibilityToTargetDistance1dot5m : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	maxVisibilityToTargetDistance = 1.5f;
}

NotMaxVisibilityToTargetDistanceChest1dot5m : MaxVisibilityToTargetDistanceChest1dot5m
{
	invert = true;
}

MaxVisibilityToTargetDistanceChest1dot5m : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	maxVisibilityToTargetDistance = 1.5f;
	isCombatTargetVisibleFrom = "AIAdditionalTraceType.Hip";
}

NotMaxVisibilityToTargetDistanceHip1dot5m : MaxVisibilityToTargetDistanceChest1dot5m
{
	invert = true;
}

MaxVisibilityToTargetDistanceHip1dot5m : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
	maxVisibilityToTargetDistance = 1.5f;
	isCombatTargetVisibleFrom = "AIAdditionalTraceType.Hip";
}

NotFollower : Follower
{
	invert = true;
}

Follower : AITargetCond
{
	target = "AIActionTarget.FriendlyTarget";
}

NotTopThreat : TopThreat
{
	invert = true;
}

TopThreat : AITargetCond
{
	target = "AIActionTarget.TopThreat";
}

NotStimTarget : StimTarget
{
	invert = true;
}

StimTarget : AITargetCond
{
	target = "AIActionTarget.StimTarget";
}

NotCombatTarget : CombatTarget
{
	invert = true;
}

CombatTarget : AITargetCond
{
	target = "AIActionTarget.CombatTarget";
}

NotFurthestSquadmate : FurthestSquadmate
{
	invert = true;
}

FurthestSquadmate : AITargetCond
{
	target = "AIActionTarget.FurthestSquadmate";
}

NotNearestSquadmate : NearestSquadmate
{
	invert = true;
}

NearestSquadmate : AITargetCond
{
	target = "AIActionTarget.NearestSquadmate";
}

NotNetrunnerProxy : NetrunnerProxy
{
	invert = true;
}

NetrunnerProxy : AITargetCond
{
	target = "AIActionTarget.NetrunnerProxy";
}

NotCurrentNetrunnerProxy : CurrentNetrunnerProxy
{
	invert = true;
}

CurrentNetrunnerProxy : AITargetCond
{
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

NotCurrentNetrunnerProxyIsActive : AITargetCond
{
	target = "AIActionTarget.CurrentNetrunnerProxy";
	isActive = 0;
}

OwnerIsActive : AITargetCond
{
	target = "AIActionTarget.Owner";
	isActive = 1;
}

NotNearestDefeatedSquadmate : NearestDefeatedSquadmate
{
	invert = true;
}

NearestDefeatedSquadmate : AITargetCond
{
	target = "AIActionTarget.NearestDefeatedSquadmate";
}

NotIsFollower : IsFollower
{
	invert = true;
}

IsFollower : AITargetCond
{
	target = "AIActionTarget.FriendlyTarget";
}

InStatesMoving : AIStateCond
{
	inStates = 
	[
		"Moving"
	];
}

NotInStatesCombat : InStatesCombat
{
	invert = true;
}

InStatesCombat : AIStateCond
{
	inStates = 
	[
		"Combat"
	];
}

NotInStatesStealth : InStatesStealth
{
	invert = true;
}

InStatesStealth : AIStateCond
{
	inStates = 
	[
		"Stealth"
	];
}

NotInStatesStatic : InStatesStatic
{
	invert = true;
}

InStatesStatic : AIStateCond
{
	inStates = 
	[
		"Static"
	];
}

NotInStatesSprint : InStatesSprint
{
	invert = true;
}

InStatesSprint : AIStateCond
{
	inStates = 
	[
		"Sprint"
	];
}

NotInStatesShoot : InStatesShoot
{
	invert = true;
}

InStatesShoot : AIStateCond
{
	inStates = 
	[
		"Shoot"
	];
}

NotInStatesReload : InStatesReload
{
	invert = true;
}

InStatesReload : AIStateCond
{
	inStates = 
	[
		"Reload"
	];
}

NotInStatesDefend : InStatesDefend
{
	invert = true;
}

InStatesDefend : AIStateCond
{
	inStates = 
	[
		"Defend"
	];
}

NotInStatesUnstoppable : InStatesUnstoppable
{
	invert = true;
}

InStatesUnstoppable : AIStateCond
{
	inStates = 
	[
		"Unstoppable"
	];
}

NotTargetInStatesBlock : TargetInStatesBlock
{
	invert = true;
}

TargetInStatesBlock : AIStateCond
{
	target = "AIActionTarget.CombatTarget";
	inStates = 
	[
		"Block"
	];
}

NotTargetInStatesCrouch : TargetInStatesCrouch
{
	invert = true;
}

TargetInStatesCrouch : AIStateCond
{
	target = "AIActionTarget.CombatTarget";
	inStates = 
	[
		"Crouch"
	];
}

NotTargetInStatesShoot : TargetInStatesShoot
{
	invert = true;
}

TargetInStatesShoot : AIStateCond
{
	target = "AIActionTarget.CombatTarget";
	inStates = 
	[
		"Shoot"
	];
}

NotInStatesParry : InStatesParry
{
	invert = true;
}

InStatesParry : AIStateCond
{
	inStates = 
	[
		"Parry"
	];
}

NotInStatesAttack : InStatesAttack
{
	invert = true;
}

InStatesAttack : AIStateCond
{
	inStates = 
	[
		"Attack"
	];
}

NotInStatesEquip : InStatesEquip
{
	invert = true;
}

InStatesEquip : AIStateCond
{
	inStates = 
	[
		"Equip"
	];
}

NotInStatesAlerted : InStatesAlerted
{
	invert = true;
}

InStatesAlerted : AIStateCond
{
	inStates = 
	[
		"Alerted"
	];
}

NotInStatesRelaxed : InStatesRelaxed
{
	invert = true;
}

InStatesRelaxed : AIStateCond
{
	inStates = 
	[
		"Relaxed"
	];
}

NotInStatesUnconscious : InStatesUnconscious
{
	invert = true;
}

InStatesUnconscious : AIStateCond
{
	inStates = 
	[
		"Unconscious"
	];
}

NotTargetInStatesAim : TargetInStatesAim
{
	invert = true;
}

TargetInStatesAim : AIStateCond
{
	target = "AIActionTarget.CombatTarget";
	inStates = 
	[
		"Aim"
	];
}

NotInStatesTaunt : InStatesTaunt
{
	invert = true;
}

InStatesTaunt : AIStateCond
{
	inStates = 
	[
		"Taunt"
	];
}

NotInStatesVehicleWindow : InStatesVehicleWindow
{
	invert = true;
}

InStatesVehicleWindow : AIStateCond
{
	inStates = 
	[
		"VehicleWindow"
	];
}

NotFriendlyTargetInStatesCrouch : FriendlyTargetInStatesCrouch
{
	invert = true;
}

FriendlyTargetInStatesCrouch : AIStateCond
{
	target = "AIActionTarget.FriendlyTarget";
	inStates = 
	[
		"Crouch"
	];
}

NotFriendlyTargetInStatesJump : FriendlyTargetInStatesJump
{
	invert = true;
}

FriendlyTargetInStatesJump : AIStateCond
{
	target = "AIActionTarget.FriendlyTarget";
	inStates = 
	[
		"Jump"
	];
}

NotTargetInStatesJump : TargetInStatesJump
{
	invert = true;
}

TargetInStatesJump : AIStateCond
{
	target = "AIActionTarget.CombatTarget";
	inStates = 
	[
		"Jump"
	];
}

NotFriendlyTargetInStatesSprint : FriendlyTargetInStatesSprint
{
	invert = true;
}

FriendlyTargetInStatesSprint : AIStateCond
{
	target = "AIActionTarget.FriendlyTarget";
	inStates = 
	[
		"Sprint"
	];
}

NotFriendlyTargetInStatesPublic : FriendlyTargetInStatesPublic
{
	invert = true;
}

FriendlyTargetInStatesPublic : AIStateCond
{
	target = "AIActionTarget.FriendlyTarget";
	inStates = 
	[
		"Public"
	];
}

NotActionStatesConditions : AIStateCond
{
	invert = true;
	inStates = 
	[
		"Shoot", "Reload", "ChargeAttack", "Taunt", "Attack", "Defend", "Parry", "Equip", "Unstoppable"
	];
	checkAllTypes = true;
}

ActionStatesConditions : AIStateCond
{
	inStates = 
	[
		"Shoot", "Reload", "ChargeAttack", "Taunt", "Attack", "Defend", "Parry", "Equip", "Unstoppable"
	];
}

NotMeleeStatesConditions : AIStateCond
{
	invert = true;
	inStates = 
	[
		"ChargeAttack", "Taunt", "Attack", "Defend", "Parry", "Equip", "Unstoppable"
	];
	checkAllTypes = true;
}

MeleeStatesConditions : AIStateCond
{
	inStates = 
	[
		"ChargeAttack", "Taunt", "Attack", "Defend", "Parry", "Equip", "Unstoppable"
	];
}

NotMeleeStatesExceptAttackConditions : AIStateCond
{
	invert = true;
	inStates = 
	[
		"ChargeAttack", "Taunt", "Defend", "Parry", "Equip"
	];
	checkAllTypes = true;
}

MeleeStatesExceptAttackConditions : AIStateCond
{
	inStates = 
	[
		"ChargeAttack", "Taunt", "Defend", "Parry", "Equip"
	];
}

NotMeleeStatesExceptTauntConditions : AIStateCond
{
	invert = true;
	inStates = 
	[
		"ChargeAttack", "Attack", "Defend", "Parry", "Equip", "Unstoppable"
	];
	checkAllTypes = true;
}

MeleeStatesExceptTauntConditions : AIStateCond
{
	inStates = 
	[
		"ChargeAttack", "Attack", "Defend", "Parry", "Equip", "Unstoppable"
	];
}

NotAttackAndTauntStatesConditions : AIStateCond
{
	invert = true;
	inStates = 
	[
		"Taunt", "Attack", "Unstoppable"
	];
	checkAllTypes = true;
}

AttackAndTauntStatesConditions : AIStateCond
{
	inStates = 
	[
		"Taunt", "Attack", "Unstoppable"
	];
}

NotMeleeStatesAttackConditions : AIStateCond
{
	invert = true;
	inStates = 
	[
		"ChargeAttack", "Attack", "Unstoppable"
	];
	checkAllTypes = true;
}

MeleeStatesAttackConditions : AIStateCond
{
	inStates = 
	[
		"ChargeAttack", "Attack", "Unstoppable"
	];
}

StimTargetNotInCarryState : AIStateCond
{
	target = "AIActionTarget.StimTarget";
	inStates = 
	[
		"Carry"
	];
	invert = true;
}

PlayerNotInStatesCombat : PlayerInStatesCombat
{
	invert = true;
}

PlayerInStatesCombat : AIStateCond
{
	target = "AIActionTarget.Player";
	inStates = 
	[
		"InCombat"
	];
}

PlayerInStatesOutOfCombat : AIStateCond
{
	target = "AIActionTarget.Player";
	inStates = 
	[
		"OutOfCombat"
	];
}

PlayerInRestrictedZone : AIStateCond
{
	target = "AIActionTarget.Player";
	inStates = 
	[
		"Restricted"
	];
}

PlayerInDangerousZone : AIStateCond
{
	target = "AIActionTarget.Player";
	inStates = 
	[
		"Dangerous"
	];
}

NotPlayerInStatesDodge : PlayerInStatesDodge
{
	invert = true;
}

PlayerInStatesDodge : AIStateCond
{
	inStates = 
	[
		"Dodge"
	];
	target = "AIActionTarget.Player";
}

NotPlayerInStatesSprint : PlayerInStatesSprint
{
	invert = true;
}

PlayerInStatesSprint : AIStateCond
{
	inStates = 
	[
		"Sprint"
	];
	target = "AIActionTarget.Player";
}

NotPlayerInStatesStand : PlayerInStatesStand
{
	invert = true;
}

PlayerInStatesStand : AIStateCond
{
	inStates = 
	[
		"Stand"
	];
	target = "AIActionTarget.Player";
}

NotPlayerInStatesCrouch : PlayerInStatesCrouch
{
	invert = true;
}

PlayerInStatesCrouch : AIStateCond
{
	inStates = 
	[
		"Crouch"
	];
	target = "AIActionTarget.Player";
}

NotTicketTakeCover : TicketTakeCover
{
	invert = true;
}

TicketTakeCover : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.TakeCover"
	];
}

NotTicketReload : TicketReload
{
	invert = true;
}

TicketReload : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Reload"
	];
}

NotTicketEquip : TicketEquip
{
	invert = true;
}

TicketEquip : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Equip"
	];
}

NotTicketMeleeEquip : TicketMeleeEquip
{
	invert = true;
}

TicketMeleeEquip : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.EquipMelee"
	];
}

NotTicketQuickhack : TicketQuickhack
{
	invert = true;
}

TicketQuickhack : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Quickhack"
	];
}

NotTicketCharge : TicketCharge
{
	invert = true;
}

TicketCharge : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Charge"
	];
}

NotTicketAndroidMelee : TicketAndroidMelee
{
	invert = true;
}

TicketAndroidMelee : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.AndroidMelee"
	];
}

NotTicketMelee : TicketMelee
{
	invert = true;
}

TicketMelee : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Melee"
	];
}

NotTicketDodge : TicketDodge
{
	invert = true;
}

TicketDodge : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Dodge"
	];
}

NotTicketMeleeApproach : TicketMeleeApproach
{
	invert = true;
}

TicketMeleeApproach : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.MeleeApproach"
	];
}

NotTicketCatchUp : TicketCatchUp
{
	invert = true;
}

TicketCatchUp : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.CatchUp"
	];
}

NotTicketBlock : TicketBlock
{
	invert = true;
}

TicketBlock : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Block"
	];
}

NotTicketSync : TicketSync
{
	invert = true;
}

TicketSync : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Sync"
	];
}

NotTicketTaunt : TicketTaunt
{
	invert = true;
}

TicketTaunt : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Taunt"
	];
}

NotTicketGrenadeThrow : TicketGrenadeThrow
{
	invert = true;
}

TicketGrenadeThrow : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.GrenadeThrow"
	];
}

NotTicketShoot : TicketShoot
{
	invert = true;
}

TicketShoot : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Shoot"
	];
}

NotTicketStrafe : TicketStrafe
{
	invert = true;
}

TicketStrafe : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.Strafe"
	];
}

NotTicketCheckCatchUp : TicketCheckCatchUp
{
	invert = true;
}

TicketCheckCatchUp : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.CatchUp"
	];
}

NotTicketCheckSmokeGrenadeThrow : TicketCheckSmokeGrenadeThrow
{
	invert = true;
}

TicketCheckSmokeGrenadeThrow : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.SmokeGrenadeThrow"
	];
}

NotTicketCheckStrafe : TicketCheckStrafe
{
	invert = true;
}

TicketCheckStrafe : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.Strafe"
	];
}

NotTicketCheckShoot : TicketCheckShoot
{
	invert = true;
}

TicketCheckShoot : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.Shoot"
	];
}

NotTicketCatchUpToMeleePlayerOnHard : TicketCatchUpToMeleePlayerOnHard
{
	invert = true;
}

TicketCatchUpToMeleePlayerOnHard : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.CatchUpToMeleePlayerOnHard"
	];
}

NotTicketCatchUpToMeleePlayerOnVeryHard : TicketCatchUpToMeleePlayerOnVeryHard
{
	invert = true;
}

TicketCatchUpToMeleePlayerOnVeryHard : AISquadCond
{
	hasTickets = 
	[
		"AITicketType.CatchUpToMeleePlayerOnVeryHard"
	];
}

TicketCheckAndroidMelee : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.AndroidMelee"
	];
}

TicketCheckMelee : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.Melee"
	];
}

TicketCheckMeleeSupport : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.MeleeSupport"
	];
}

TicketCheckMeleeApproach : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.MeleeApproach"
	];
}

TicketCheckBattleCry : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.BattleCry"
	];
}

TicketCheckMediumRing : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.MediumRing"
	];
}

TicketCheckFarRing : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.FarRing"
	];
}

TicketCheckExtremeRing : AISquadCond
{
	ticketsConditionCheck = 
	[
		"AITicketType.ExtremeRing"
	];
}

NotOptimalDistance : AIOptimalDistanceCond
{
	invert = true;
}

OptimalDistance : AIOptimalDistanceCond
{
}

OptimalDistanceMeleeRing : AIOptimalDistanceCond
{
	checkRings = 
	[
		"AIRingType.Melee"
	];
}

OptimalDistance2mToleranceMeleeRing : AIOptimalDistanceCond
{
	toleranceOffset = 2.f;
	checkRings = 
	[
		"AIRingType.Melee"
	];
}

OptimalDistanceCloseRing : AIOptimalDistanceCond
{
	checkRings = 
	[
		"AIRingType.Close"
	];
}

NotOptimalDistance2mToleranceCloseRing : OptimalDistance2mToleranceCloseRing
{
	invert = true;
}

OptimalDistance2mToleranceCloseRing : AIOptimalDistanceCond
{
	toleranceOffset = 2.f;
	checkRings = 
	[
		"AIRingType.Close"
	];
}

OptimalDistanceMediumRing : AIOptimalDistanceCond
{
	checkRings = 
	[
		"AIRingType.Medium"
	];
}

OptimalDistance2mToleranceMediumRing : AIOptimalDistanceCond
{
	toleranceOffset = 2.f;
	checkRings = 
	[
		"AIRingType.Medium"
	];
}

OptimalDistanceFarRing : AIOptimalDistanceCond
{
	checkRings = 
	[
		"AIRingType.Far"
	];
}

OptimalDistance2mToleranceFarRing : AIOptimalDistanceCond
{
	toleranceOffset = 2.f;
	checkRings = 
	[
		"AIRingType.Far"
	];
}

OptimalDistanceExtremeRing : AIOptimalDistanceCond
{
	checkRings = 
	[
		"AIRingType.Extreme"
	];
}

OptimalDistance2mToleranceExtremeRing : AIOptimalDistanceCond
{
	toleranceOffset = 2.f;
	checkRings = 
	[
		"AIRingType.Extreme"
	];
}

NotOptimalDistance4mToleranceCloseRing : OptimalDistance4mToleranceCloseRing
{
	invert = true;
}

OptimalDistance4mToleranceCloseRing : AIOptimalDistanceCond
{
	toleranceOffset = 4.f;
	checkRings = 
	[
		"AIRingType.Close"
	];
}

NotOptimalDistance2mTolerance : OptimalDistance2mTolerance
{
	invert = true;
}

OptimalDistance2mTolerance : AIOptimalDistanceCond
{
	toleranceOffset = 2.f;
}

NotOptimalDistance4mTolerance : OptimalDistance4mTolerance
{
	invert = true;
}

OptimalDistance4mTolerance : AIOptimalDistanceCond
{
	toleranceOffset = 4.f;
}

NotOptimalDistance5mTolerance : OptimalDistance5mTolerance
{
	invert = true;
}

OptimalDistance5mTolerance : AIOptimalDistanceCond
{
	toleranceOffset = 5.f;
}

NotOptimalDistance6mToleranceFailWhenCloser : OptimalDistance6mToleranceFailWhenCloser
{
	invert = true;
}

OptimalDistance6mToleranceFailWhenCloser : AIOptimalDistanceCond
{
	toleranceOffset = 6.f;
	failWhenCloserThanCurrentRing = true;
}

OptimalDistance10mTolerance : AIOptimalDistanceCond
{
	toleranceOffset = 10.f;
}

NotFriendlyFire : AIFriendlyFireCond
{
	invert = true;
}

FriendlyFire : AIFriendlyFireCond
{
}

NotAICommand : Condition.AICommand
{
	invert = true;
}

AICommand : AICommandCond
{
	hasCommands = 
	[
		"AICommand"
	];
}

NotAIMoveCommand : AIMoveCommand
{
	invert = true;
}

AIMoveCommand : AICommandCond
{
	hasCommands = 
	[
		"AIMoveCommand"
	];
}

NotAIForceShootCommand : AIForceShootCommand
{
	invert = true;
}

AIForceShootCommand : AICommandCond
{
	hasCommands = 
	[
		"AIForceShootCommand"
	];
}

NotAIShootCommand : AIShootCommand
{
	invert = true;
}

AIShootCommand : AICommandCond
{
	hasCommands = 
	[
		"AIShootCommand"
	];
}

NotAIScanTargetCommand : AIScanTargetCommand
{
	invert = true;
}

AIScanTargetCommand : AICommandCond
{
	hasCommands = 
	[
		"AIScanTargetCommand"
	];
}

NotAIUseWorkspotCommand : AIUseWorkspotCommand
{
	invert = true;
}

AIUseWorkspotCommand : AICommandCond
{
	hasCommands = 
	[
		"AIUseWorkspotCommand"
	];
}

NotAIUseCoverCommand : AIUseCoverCommand
{
	invert = true;
}

AIUseCoverCommand : AICommandCond
{
	hasCommands = 
	[
		"AIUseCoverCommand"
	];
}

NotAIHoldPositionCommand : AIHoldPositionCommand
{
	invert = true;
}

AIHoldPositionCommand : AICommandCond
{
	hasCommands = 
	[
		"AIHoldPositionCommand"
	];
}

NotAIMeleeAttackCommand : AIMeleeAttackCommand
{
	invert = true;
}

AIMeleeAttackCommand : AICommandCond
{
	hasCommands = 
	[
		"AIMeleeAttackCommand"
	];
}

NotAIMoveToCommand : AIMoveToCommand
{
	invert = true;
}

AIMoveToCommand : AICommandCond
{
	hasCommands = 
	[
		"AIMoveToCommand"
	];
}

NotAIMoveOnSplineCommand : AIMoveOnSplineCommand
{
	invert = true;
}

AIMoveOnSplineCommand : AICommandCond
{
	hasCommands = 
	[
		"AIMoveOnSplineCommand"
	];
}

NotAIAnimMoveOnSplineCommand : AIAnimMoveOnSplineCommand
{
	invert = true;
}

AIAnimMoveOnSplineCommand : AICommandCond
{
	hasCommands = 
	[
		"AIAnimMoveOnSplineCommand"
	];
}

NotAIFollowTargetCommand : AIFollowTargetCommand
{
	invert = true;
}

AIFollowTargetCommand : AICommandCond
{
	hasCommands = 
	[
		"AIFollowTargetCommand"
	];
}

NotAIRootMotionCommand : AIRootMotionCommand
{
	invert = true;
}

AIRootMotionCommand : AICommandCond
{
	hasCommands = 
	[
		"AIRootMotionCommand"
	];
}

NotAIMoveToCoverCommand : AIMoveToCoverCommand
{
	invert = true;
}

AIMoveToCoverCommand : AICommandCond
{
	hasCommands = 
	[
		"AIMoveToCoverCommand"
	];
}

NotAIAimAtTargetCommand : AIAimAtTargetCommand
{
	invert = true;
}

AIAimAtTargetCommand : AICommandCond
{
	hasCommands = 
	[
		"AIAimAtTargetCommand"
	];
}

NotAIThrowGrenadeCommand : AIThrowGrenadeCommand
{
	invert = true;
}

AIThrowGrenadeCommand : AICommandCond
{
	hasCommands = 
	[
		"AIThrowGrenadeCommand"
	];
}

NotAIThrowGrenadeForcedCommand : AIThrowGrenadeCommand
{
	invert = true;
}

AIThrowGrenadeForcedCommand : AICommandCond
{
	hasCommands = 
	[
		"AIThrowGrenadeForcedCommand"
	];
}

NotAISwitchToPrimaryWeaponCommand : AISwitchToPrimaryWeaponCommand
{
	invert = true;
}

AISwitchToPrimaryWeaponCommand : AICommandCond
{
	hasCommands = 
	[
		"AISwitchToPrimaryWeaponCommand"
	];
}

NotAISwitchToSecondaryWeaponCommand : AISwitchToSecondaryWeaponCommand
{
	invert = true;
}

AISwitchToSecondaryWeaponCommand : AICommandCond
{
	hasCommands = 
	[
		"AISwitchToSecondaryWeaponCommand"
	];
}

AICombatTargetCommand : AICommandCond
{
	hasCommands = 
	[
		"InjectCombatTargetCommand"
	];
}

NotAICombatTargetCommand : AICombatTargetCommand
{
	invert = true;
}

AICombatThreatCommand : AICommandCond
{
	hasCommands = 
	[
		"InjectCombatThreatCommand"
	];
}

NotAICombatThreatCommand : AICombatThreatCommand
{
	invert = true;
}

NotIsCivilian : IsCivilian
{
	invert = true;
}

IsCivilian : AIReactionCond
{
	preset = "ReactionPresets.Civilian_Neutral";
}

IsMechanicalNonCombat : AIReactionCond
{
	preset = "ReactionPresets.Mechanical_NonCombat";
}

IsGrenadeLandedStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.GrenadeLanded"
	];
}

IsEnvironmentalHazardStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.EnvironmentalHazard"
	];
}

NotDrivingStim : DrivingStim
{
	invert = true;
}

DrivingStim : AIReactionCond
{
	stimType = 
	[
		"StimTypes.Driving"
	];
}

ExplosionStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.Explosion"
	];
}

ReprimandFinalWarningStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.ReprimandFinalWarning"
	];
}

DeviceExplosionStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.DeviceExplosion"
	];
}

LandingVeryHardStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.LandingVeryHard"
	];
}

DyingStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.Dying"
	];
}

CarAlarmStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.CarAlarm"
	];
}

GunshotStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.Gunshot"
	];
}

SilencedGunshotStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.SilencedGunshot"
	];
}

AnyGunshotStimType : AIActionOR
{
	OR = 
	[
		"Condition.GunshotStimType", "Condition.SilencedGunshotStimType"
	];
}

CallStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.Call", "StimTypes.CombatCall"
	];
}

NotWhistleStimType : WhistleStimType
{
	invert = true;
}

WhistleStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.Whistle", "StimTypes.CombatWhistle"
	];
}

DrivingStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.Driving"
	];
}

BulletStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.Bullet"
	];
}

MeleeHitStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.MeleeHit"
	];
}

MeleeAttackStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.MeleeAttack"
	];
}

CombatStimTypes : AIReactionCond
{
	stimType = 
	[
		"StimTypes.MeleeHit", "StimTypes.CombatHit", "StimTypes.Gunshot", "StimTypes.Explosion", "StimTypes.Combat", "StimTypes.MeleeAttack"
	];
}

NotCombatStimTypes : CombatStimTypes
{
	invert = true;
}

CombatHitStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.CombatHit"
	];
}

NotAreaEffectStimType : AreaEffectStimType
{
	invert = true;
}

AreaEffectStimType : AIReactionCond
{
	stimType = 
	[
		"StimTypes.AreaEffect"
	];
}

SuspiciousTargetEscalation : AIReactionCond
{
	stimType = 
	[
		"StimTypes.IllegalAction", "StimTypes.IllegalActionNoCombat", "StimTypes.IllegalInteraction", "StimTypes.WeaponDisplayed", "StimTypes.Gunshot", "StimTypes.AimingAt", "StimTypes.WeaponSafe"
	];
}

FearThreshold : AIReactionCond
{
	thresholdValue = "BaseStatPools.Fear";
}

InvestigateController : AIReactionCond
{
	investigateController = true;
}

InvestigateReaction : AIReactionCond
{
	reactionBehaviorName = "Investigate";
}

NotHasAnyItem : HasAnyItem
{
	invert = true;
}

HasAnyItem : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
		} : AISlotCond
	];
}

NotHasAnyItemSpawning : AIActionAND
{
	AND = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			checkIfEmptySlotIsSpawningItem = 0;
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			checkIfEmptySlotIsSpawningItem = 0;
		} : AISlotCond
	];
}

HasAnyItemSpawning : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			checkIfEmptySlotIsSpawningItem = 1;
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			checkIfEmptySlotIsSpawningItem = 1;
		} : AISlotCond
	];
}

NotHasAnyWeapon : HasAnyWeapon
{
	invert = true;
}

HasAnyWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
		} : AISlotCond
	];
}

StimTargetHasNotAnyWeapon : StimTargetHasAnyWeapon
{
	invert = true;
}

StimTargetHasAnyWeapon : AIActionOR
{
	OR = 
	[
		{
			target = "AIActionTarget.StimTarget";
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
		} : AISlotCond, 
		{
			target = "AIActionTarget.StimTarget";
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
		} : AISlotCond
	];
}

NotFriendlyTargetHasWeapon : FriendlyTargetHasWeapon
{
	invert = true;
}

FriendlyTargetHasWeapon : AISlotCond
{
	slot = "AttachmentSlots.WeaponRight";
	itemCategory = "ItemCategory.Weapon";
	target = "AIActionTarget.FriendlyTarget";
}

NotHasAnyWeaponRight : HasAnyWeaponRight
{
	invert = true;
}

HasAnyWeaponRight : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
		} : AISlotCond
	];
}

NotHasAnyWeaponLeft : HasAnyWeaponLeft
{
	invert = true;
}

HasAnyWeaponLeft : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
		} : AISlotCond
	];
}

NotTargetHasMeleeWeapon : TargetHasMeleeWeapon
{
	invert = true;
}

TargetHasMeleeWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "MeleeWeapon";
			target = "AIActionTarget.CombatTarget";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "MeleeWeapon";
			target = "AIActionTarget.CombatTarget";
		} : AISlotCond
	];
}

NotPlayerHasMeleeWeapon : PlayerHasMeleeWeapon
{
	invert = true;
}

PlayerHasMeleeWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "MeleeWeapon";
			target = "AIActionTarget.Player";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "MeleeWeapon";
			target = "AIActionTarget.Player";
		} : AISlotCond
	];
}

NotHasMeleeWeapon : HasMeleeWeapon
{
	invert = true;
}

HasMeleeWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "MeleeWeapon";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "MeleeWeapon";
		} : AISlotCond
	];
}

NotTargetHasRangedWeapon : TargetHasRangedWeapon
{
	invert = true;
}

TargetHasRangedWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "RangedWeapon";
			target = "AIActionTarget.CombatTarget";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "RangedWeapon";
			target = "AIActionTarget.CombatTarget";
		} : AISlotCond
	];
}

NotHasRangedWeapon : HasRangedWeapon
{
	invert = true;
}

HasRangedWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "RangedWeapon";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "RangedWeapon";
		} : AISlotCond
	];
}

NotHasSemiAutoWeapon : HasSemiAutoWeapon
{
	invert = true;
}

HasSemiAutoWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			triggerModes = 
			[
				"TriggerMode.SemiAuto"
			];
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			triggerModes = 
			[
				"TriggerMode.SemiAuto"
			];
		} : AISlotCond
	];
}

NotHasFullAutoWeapon : HasFullAutoWeapon
{
	invert = true;
}

HasFullAutoWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			triggerModes = 
			[
				"TriggerMode.FullAuto"
			];
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			triggerModes = 
			[
				"TriggerMode.FullAuto"
			];
		} : AISlotCond
	];
}

NotTargetHasFullAutoWeapon : TargetHasFullAutoWeapon
{
	invert = true;
}

TargetHasFullAutoWeapon : AIActionOR
{
	OR = 
	[
		{
			target = "AIActionTarget.CombatTarget";
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			triggerModes = 
			[
				"TriggerMode.FullAuto"
			];
		} : AISlotCond, 
		{
			target = "AIActionTarget.CombatTarget";
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			triggerModes = 
			[
				"TriggerMode.FullAuto"
			];
		} : AISlotCond
	];
}

NotHasChargeWeapon : HasChargeWeapon
{
	invert = true;
}

HasChargeWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			triggerModes = 
			[
				"TriggerMode.Charge"
			];
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			triggerModes = 
			[
				"TriggerMode.Charge"
			];
		} : AISlotCond
	];
}

NotBurstWeapon : HasBurstWeapon
{
	invert = true;
}

HasBurstWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			triggerModes = 
			[
				"TriggerMode.Burst"
			];
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			triggerModes = 
			[
				"TriggerMode.Burst"
			];
		} : AISlotCond
	];
}

NotRequestedTriggerModeSemiAuto : RequestedTriggerModeSemiAuto
{
	invert = true;
}

RequestedTriggerModeSemiAuto : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			requestedTriggerModes = "TriggerMode.SemiAuto";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			requestedTriggerModes = "TriggerMode.SemiAuto";
		} : AISlotCond
	];
}

NotRequestedTriggerModeFullAuto : RequestedTriggerModeFullAuto
{
	invert = true;
}

RequestedTriggerModeFullAuto : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			requestedTriggerModes = "TriggerMode.FullAuto";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			requestedTriggerModes = "TriggerMode.FullAuto";
		} : AISlotCond
	];
}

NotRequestedTriggerModeCharge : RequestedTriggerModeCharge
{
	invert = true;
}

RequestedTriggerModeCharge : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			requestedTriggerModes = "TriggerMode.Charge";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			requestedTriggerModes = "TriggerMode.Charge";
		} : AISlotCond
	];
}

NotRequestedTriggerModeBurst : RequestedTriggerModeBurst
{
	invert = true;
}

RequestedTriggerModeBurst : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			requestedTriggerModes = "TriggerMode.Burst";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			requestedTriggerModes = "TriggerMode.Burst";
		} : AISlotCond
	];
}

NotHasTechWeapon : HasTechWeapon
{
	invert = true;
}

HasTechWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "RangedWeapon";
			evolution = "WeaponEvolution.Tech";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "RangedWeapon";
			evolution = "WeaponEvolution.Tech";
		} : AISlotCond
	];
}

NotHasSmartWeapon : HasSmartWeapon
{
	invert = true;
}

HasSmartWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "RangedWeapon";
			evolution = "WeaponEvolution.Smart";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemCategory = "ItemCategory.Weapon";
			itemTag = "RangedWeapon";
			evolution = "WeaponEvolution.Smart";
		} : AISlotCond
	];
}

NotHasKatana : HasKatana
{
	invert = true;
}

HasKatana : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Katana";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Katana";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Sword";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Sword";
		} : AISlotCond
	];
}

NotHasKnife : HasKnife
{
	invert = true;
}

HasKnife : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Knife";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Knife";
		} : AISlotCond
	];
}

NotHasMantisBlades : HasMantisBlades
{
	invert = true;
}

HasMantisBlades : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Cyb_MantisBlades";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Cyb_MantisBlades";
		} : AISlotCond
	];
}

NotHasMachete : HasMachete
{
	invert = true;
}

HasMachete : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Machete";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Machete";
		} : AISlotCond
	];
}

NotHasHammer : HasHammer
{
	invert = true;
}

HasHammer : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Hammer";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Hammer";
		} : AISlotCond
	];
}

NotHasOneHandedClub : HasOneHandedClub
{
	invert = true;
}

HasOneHandedClub : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_OneHandedClub";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_OneHandedClub";
		} : AISlotCond
	];
}

NotHasTwoHandedClub : HasTwoHandedClub
{
	invert = true;
}

HasTwoHandedClub : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_TwoHandedClub";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_TwoHandedClub";
		} : AISlotCond
	];
}

NotHasShortBlade : HasShortBlade
{
	invert = true;
}

HasShortBlade : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_ShortBlade";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_ShortBlade";
		} : AISlotCond
	];
}

NotHasLongBlade : HasLongBlade
{
	invert = true;
}

HasLongBlade : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_LongBlade";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_LongBlade";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Axe";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Axe";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Chainsword";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Chainsword";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Machete";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Machete";
		} : AISlotCond
	];
}

NotHasShotgun : HasShotgun
{
	invert = true;
}

HasShotgun : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Shotgun";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_ShotgunDual";
		} : AISlotCond
	];
}

NotPlayerHasShotgun : PlayerHasShotgun
{
	invert = true;
}

PlayerHasShotgun : AIActionOR
{
	OR = 
	[
		{
			target = "AIActionTarget.Player";
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Shotgun";
		} : AISlotCond, 
		{
			target = "AIActionTarget.Player";
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_ShotgunDual";
		} : AISlotCond
	];
}

PlayerHasHandgun : AIActionOR
{
	OR = 
	[
		{
			target = "AIActionTarget.Player";
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Handgun";
		} : AISlotCond, 
		{
			target = "AIActionTarget.Player";
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Handgun";
		} : AISlotCond
	];
}

PlayerHasPrecisionRiffle : AIActionOR
{
	OR = 
	[
		{
			target = "AIActionTarget.Player";
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_PrecisionRifle";
		} : AISlotCond, 
		{
			target = "AIActionTarget.Player";
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_PrecisionRifle";
		} : AISlotCond
	];
}

NotHasMachineGun : HasMachineGun
{
	invert = true;
}

HasMachineGun : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_LightMachineGun";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_HeavyMachineGun";
		} : AISlotCond
	];
}

NotHasAssaultWeapon : HasAssaultWeapon
{
	invert = true;
}

HasAssaultWeapon : AIActionOR
{
	OR = 
	[
		"Condition.HasShotgun", "Condition.HasMachineGun"
	];
}

NotHasHeavyMachineGun : HasHeavyMachineGun
{
	invert = true;
}

HasHeavyMachineGun : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_HeavyMachineGun";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_HeavyMachineGun";
		} : AISlotCond
	];
}

NotHasRifle : HasRifle
{
	invert = true;
}

HasRifle : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Rifle";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Rifle";
		} : AISlotCond
	];
}

NotHasSMG : HasSMG
{
	invert = true;
}

HasSMG : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_SubmachineGun";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_SubmachineGun";
		} : AISlotCond
	];
}

NotHasSniperWeapon : HasSniperWeapon
{
	invert = true;
}

HasSniperWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_PrecisionRifle";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_SniperRifle";
		} : AISlotCond
	];
}

NotHasShotgunWeapon : HasShotgunWeapon
{
	invert = true;
}

HasShotgunWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Shotgun";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_ShotgunDual";
		} : AISlotCond
	];
}

NotHasHandgunWeapon : HasHandgunWeapon
{
	invert = true;
}

HasHandgunWeapon : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Handgun";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Revolver";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Handgun";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Revolver";
		} : AISlotCond
	];
}

NotHasHandgunWeaponLeft : HasHandgunWeaponLeft
{
	invert = true;
}

HasHandgunWeaponLeft : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Handgun";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Revolver";
		} : AISlotCond
	];
}

NotHasHandgunWeaponRight : HasHandgunWeaponRight
{
	invert = true;
}

HasHandgunWeaponRight : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Handgun";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Revolver";
		} : AISlotCond
	];
}

NotHasHandgunDual : HasHandgunDual
{
	invert = true;
}

HasHandgunDual : AIActionAND
{
	AND = 
	[
		{
			OR = 
			[
				{
					slot = "AttachmentSlots.WeaponRight";
					itemType = "ItemType.Wea_Handgun";
				} : AISlotCond, 
				{
					slot = "AttachmentSlots.WeaponRight";
					itemType = "ItemType.Wea_Revolver";
				} : AISlotCond
			];
		} : AIActionOR, 
		{
			OR = 
			[
				{
					slot = "AttachmentSlots.WeaponLeft";
					itemType = "ItemType.Wea_Handgun";
				} : AISlotCond, 
				{
					slot = "AttachmentSlots.WeaponLeft";
					itemType = "ItemType.Wea_Revolver";
				} : AISlotCond
			];
		} : AIActionOR
	];
}

ArmedTwoHandedWeapon : AIActionAND
{
	AND = 
	[
		"Condition.HasAnyWeapon", {
			OR = 
			[
				{
					itemType = 
					[
						"ItemType.Wea_Rifle", "ItemType.Wea_Shotgun", "ItemType.Wea_SniperRifle", "ItemType.Wea_LightMachineGun", "ItemType.Wea_AssaultRifle", "ItemType.Wea_PrecisionRifle", "ItemType.Wea_ShotgunDual", "ItemType.Wea_SubmachineGun", "ItemType.Wea_HeavyMachineGun"
					];
				} : AIHasWeapon
			];
		} : AIActionOR
	];
}

ArmedOneHandedWeapon : AIActionAND
{
	AND = 
	[
		"Condition.HasAnyWeapon", {
			OR = 
			[
				{
					itemType = 
					[
						"ItemType.Wea_Handgun", "ItemType.Wea_Revolver"
					];
				} : AIHasWeapon
			];
		} : AIActionOR
	];
}

IsUnarmed : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Fists";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Fists";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Cyb_StrongArms";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Cyb_StrongArms";
		} : AISlotCond, 
		{
			AND = 
			[
				{
					slot = "AttachmentSlots.WeaponRight";
					itemCategory = "ItemCategory.Weapon";
					invert = true;
				} : AISlotCond, 
				{
					slot = "AttachmentSlots.WeaponLeft";
					itemCategory = "ItemCategory.Weapon";
					invert = true;
				} : AISlotCond
			];
		} : AIActionAND
	];
}

NotHasFistsWeaponEquipped : HasFistsWeaponEquipped
{
	invert = true;
}

HasFistsWeaponEquipped : AIActionOR
{
	OR = 
	[
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Wea_Fists";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Wea_Fists";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponRight";
			itemType = "ItemType.Cyb_StrongArms";
		} : AISlotCond, 
		{
			slot = "AttachmentSlots.WeaponLeft";
			itemType = "ItemType.Cyb_StrongArms";
		} : AISlotCond
	];
}

NotHasAdamSmasherFistsWeaponEquipped : HasAdamSmasherFistsWeaponEquipped
{
	invert = true;
}

HasAdamSmasherFistsWeaponEquipped : AISlotCond
{
	slot = "AttachmentSlots.RightWrist";
	itemType = "ItemType.Wea_Fists";
}

NotHasAdamSmasherRightPlasmaCutterEquipped : AdamSmasherRightPlasmaCutterEquipped
{
	invert = true;
}

AdamSmasherRightPlasmaCutterEquipped : AISlotCond
{
	slot = "AttachmentSlots.SmasherPlasmaWeaponRight";
	itemID = "Items.smasher_plasma_cutter";
}

NotHasAdamSmasherLeftPlasmaCutterEquipped : AdamSmasherLeftPlasmaCutterEquipped
{
	invert = true;
}

AdamSmasherLeftPlasmaCutterEquipped : AISlotCond
{
	slot = "AttachmentSlots.SmasherPlasmaWeaponLeft";
	itemID = "Items.smasher_plasma_cutter";
}

NotHasAdamSmasherRocketLauncherEquipped : HasAdamSmasherRocketLauncherEquipped
{
	invert = true;
}

HasAdamSmasherRocketLauncherEquipped : AISlotCond
{
	slot = "AttachmentSlots.SmasherMissileRain";
	itemID = "Items.Smasher_Launcher_Rain_Left";
}

NotHasChimeraMeleeWeaponEquipped : HasChimeraMeleeWeaponEquipped
{
	invert = true;
}

HasChimeraMeleeWeaponEquipped : AISlotCond
{
	slot = "AttachmentSlots.ChimeraMelee";
	itemID = "Items.chimera_melee";
}

NotHasChimeraGasCloudEquipped : HasChimeraGasCloudEquipped
{
	invert = true;
}

HasChimeraGasCloudEquipped : AISlotCond
{
	slot = "AttachmentSlots.ChimeraGasCloud";
	itemID = "Items.chimera_gas_cloud";
}

NotHasChimeraRainRocketLauncherLeftEquipped : HasChimeraRainRocketLauncherLeftEquipped
{
	invert = true;
}

HasChimeraRainRocketLauncherLeftEquipped : AISlotCond
{
	slot = "AttachmentSlots.LeftShoulder";
	itemID = "Items.Chimera_Launcher_Rain_Left";
}

NotHasChimeraRainRocketLauncherRightEquipped : HasChimeraRainRocketLauncherRightEquipped
{
	invert = true;
}

HasChimeraRainRocketLauncherRightEquipped : AISlotCond
{
	slot = "AttachmentSlots.RightShoulder";
	itemID = "Items.Chimera_Launcher_Rain_Right";
}

NotHasChimeraTrackRocketLauncherLeftEquipped : HasChimeraTrackRocketLauncherLeftEquipped
{
	invert = true;
}

HasChimeraTrackRocketLauncherLeftEquipped : AISlotCond
{
	slot = "AttachmentSlots.LeftShoulderTrack";
	itemID = "Items.Chimera_Launcher_Track_Left";
}

NotHasChimeraTrackRocketLauncherRightEquipped : HasChimeraTrackRocketLauncherRightEquipped
{
	invert = true;
}

HasChimeraTrackRocketLauncherRightEquipped : AISlotCond
{
	slot = "AttachmentSlots.RightShoulderTrack";
	itemID = "Items.Chimera_Launcher_Track_Right";
}

NotHasChimeraCannonEquipped : HasChimeraCannonEquipped
{
	invert = true;
}

HasChimeraCannonEquipped : AISlotCond
{
	slot = "AttachmentSlots.Cannon";
	itemID = "Items.chimera_cannon";
}

NotHasChimeraLaserEquipped : HasChimeraLaserEquipped
{
	invert = true;
}

HasChimeraLaserEquipped : AISlotCond
{
	slot = "AttachmentSlots.Laser";
	itemID = "Items.chimera_plasma_cutter";
}

NotHasChimeraCannonLaserEquipped : HasChimeraCannonLaserEquipped
{
	invert = true;
}

HasChimeraCannonLaserEquipped : AISlotCond
{
	slot = "AttachmentSlots.CannonLaser";
	itemID = "Items.chimera_plasma_cutter_cannon";
}

NotHasChimeraMetalstormEquipped : HasChimeraMetalstormEquipped
{
	invert = true;
}

HasChimeraMetalstormEquipped : AISlotCond
{
	slot = "AttachmentSlots.MetalstormWeapon";
	itemID = "Items.Chimera_Metalstorm";
}

NotHasChimeraMetalstormExplosiveEquipped : HasChimeraMetalstormExplosiveEquipped
{
	invert = true;
}

HasChimeraMetalstormExplosiveEquipped : AISlotCond
{
	slot = "AttachmentSlots.MetalstormWeaponExplosive";
	itemID = "Items.Chimera_Metalstorm_Explosive";
}

NotHasChimeraMetalstormRaiseSequenceEquipped : HasChimeraMetalstormRaiseSequenceEquipped
{
	invert = true;
}

HasChimeraMetalstormRaiseSequenceEquipped : AISlotCond
{
	slot = "AttachmentSlots.MetalstormWeaponRaiseSequence";
	itemID = "Items.Chimera_Metalstorm_Raise_Sequence";
}

NotHasChimeraLauncherChandelierLeftEquipped : HasChimeraMetalstormRaiseSequenceEquipped
{
	invert = true;
}

HasChimeraLauncherChandelierLeftEquipped : AISlotCond
{
	slot = "AttachmentSlots.LeftShoulderChandelier";
	itemID = "Items.Chimera_Launcher_Chandelier_Left";
}

NotHasChimeraLauncherChandelierRightEquipped : HasChimeraMetalstormRaiseSequenceEquipped
{
	invert = true;
}

HasChimeraLauncherChandelierRightEquipped : AISlotCond
{
	slot = "AttachmentSlots.RightShoulderChandelier";
	itemID = "Items.Chimera_Launcher_Chandelier_Right";
}

NotHasPrimaryEquipmentEquipped : HasPrimaryEquipmentEquipped
{
	invert = true;
}

HasPrimaryEquipmentEquipped : AISlotCond
{
	equipmentGroup = "PrimaryEquipment";
}

NotHasSecondaryEquipmentEquipped : HasSecondaryEquipmentEquipped
{
	invert = true;
}

HasSecondaryEquipmentEquipped : AISlotCond
{
	equipmentGroup = "SecondaryEquipment";
}

NotStatusEffectChimeraScreen1Hacked : StatusEffectChimeraScreen1Hacked
{
	invert = true;
}

StatusEffectChimeraScreen1Hacked : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraScreen1Hacked";
}

NotStatusEffectChimeraScreen2Hacked : StatusEffectChimeraScreen2Hacked
{
	invert = true;
}

StatusEffectChimeraScreen2Hacked : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraScreen2Hacked";
}

StatusEffectMyersNoCarCombat : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.MyersNoCarCombat";
}

NotStatusEffectMyersNoCarCombat : StatusEffectMyersNoCarCombat
{
	invert = true;
}

StatusEffectMyersNoTeleport : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.MyersNoTeleport";
}

NotStatusEffectMyersNoTeleport : StatusEffectMyersNoTeleport
{
	invert = true;
}

StatusEffectFollowerDontLeaveStealth : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.FollowerDontLeaveStealth";
}

NotStatusEffectFollowerDontLeaveStealth : StatusEffectFollowerDontLeaveStealth
{
	invert = true;
}

NotHasPrimaryEquipmentMeleeInInventory : HasPrimaryEquipmentMeleeInInventory
{
	invert = true;
}

HasPrimaryEquipmentMeleeInInventory : AIItemCond
{
	itemCategory = "ItemCategory.Weapon";
	itemTag = "MeleeWeapon";
	equipmentGroup = "PrimaryEquipment";
}

NotHasPrimaryEquipmentRangedInInventory : HasPrimaryEquipmentRangedInInventory
{
	invert = true;
}

HasPrimaryEquipmentRangedInInventory : AIItemCond
{
	itemCategory = "ItemCategory.Weapon";
	itemTag = "RangedWeapon";
	equipmentGroup = "PrimaryEquipment";
}

NotHasSecondaryEquipmentRangedInInventory : HasSecondaryEquipmentRangedInInventory
{
	invert = true;
}

HasSecondaryEquipmentRangedInInventory : AIItemCond
{
	itemCategory = "ItemCategory.Weapon";
	itemTag = "RangedWeapon";
	equipmentGroup = "SecondaryEquipment";
}

NotHasPrimaryEquipmentKatanaInInventory : HasPrimaryEquipmentKatanaInInventory
{
	invert = true;
}

HasPrimaryEquipmentKatanaInInventory : AIItemCond
{
	itemType = "ItemType.Wea_Katana";
	equipmentGroup = "PrimaryEquipment";
}

NotHasPrimaryEquipmentFistsInInventory : HasPrimaryEquipmentFistsInInventory
{
	invert = true;
}

HasPrimaryEquipmentFistsInInventory : AIItemCond
{
	itemType = "ItemType.Wea_Fists";
	equipmentGroup = "PrimaryEquipment";
}

NotHasPrimaryEquipmentRifleInInventory : HasPrimaryEquipmentRifleInInventory
{
	invert = true;
}

HasPrimaryEquipmentRifleInInventory : AIItemCond
{
	itemType = "ItemType.Wea_Rifle";
	equipmentGroup = "PrimaryEquipment";
}

NotHasPrimaryEquipmentHandgunInInventory : HasPrimaryEquipmentHandgunInInventory
{
	invert = true;
}

HasPrimaryEquipmentHandgunInInventory : AIItemCond
{
	itemType = "ItemType.Wea_Handgun";
	equipmentGroup = "PrimaryEquipment";
}

HasFistsInInventory : AIItemCond
{
	itemType = "ItemType.Wea_Fists";
}

HasKnifeInInventory : AIItemCond
{
	itemType = "ItemType.Wea_Knife";
}

HasHandgunInInventory : AIItemCond
{
	itemType = "ItemType.Wea_Handgun";
}

HasRevolverInInventory : AIItemCond
{
	itemType = "ItemType.Wea_Revolver";
}

HasRifleInInventory : AIItemCond
{
	itemType = "ItemType.Wea_Rifle";
}

HasGrenadeInInventory : AIItemCond
{
	itemType = "ItemType.Gad_Grenade";
}

HasBothHandWeaponAsPrimary : AIActionOR
{
	OR = 
	[
		{
			itemType = "ItemType.Wea_Rifle";
			equipmentGroup = "PrimaryEquipment";
		} : AIItemCond, 
		{
			itemType = "ItemType.Wea_Shotgun";
			equipmentGroup = "PrimaryEquipment";
		} : AIItemCond, 
		{
			itemType = "ItemType.Wea_SniperRifle";
			equipmentGroup = "PrimaryEquipment";
		} : AIItemCond, 
		{
			itemType = "ItemType.Wea_LightMachineGun";
			equipmentGroup = "PrimaryEquipment";
		} : AIItemCond, 
		{
			itemType = "ItemType.Wea_AssaultRifle";
			equipmentGroup = "PrimaryEquipment";
		} : AIItemCond, 
		{
			itemType = "ItemType.Wea_PrecisionRifle";
			equipmentGroup = "PrimaryEquipment";
		} : AIItemCond, 
		{
			itemType = "ItemType.Wea_ShotgunDual";
			equipmentGroup = "PrimaryEquipment";
		} : AIItemCond, 
		{
			itemType = "ItemType.Wea_SubmachineGun";
			equipmentGroup = "PrimaryEquipment";
		} : AIItemCond, 
		{
			itemType = "ItemType.Wea_HeavyMachineGun";
			equipmentGroup = "PrimaryEquipment";
		} : AIItemCond
	];
}

ValidCoversWithLOSMedium : AIValidCoversCond
{
	limitToRings = 
	[
		"AIRingType.Medium"
	];
	coversWithLOS = 1;
}

ValidCoversMedium : AIValidCoversCond
{
	limitToRings = 
	[
		"AIRingType.Medium"
	];
}

ValidCoversWithLOSFar : AIValidCoversCond
{
	limitToRings = 
	[
		"AIRingType.Far"
	];
	coversWithLOS = 1;
}

ValidCoversFar : AIValidCoversCond
{
	limitToRings = 
	[
		"AIRingType.Far"
	];
}

ValidCoversWithLOSExtreme : AIValidCoversCond
{
	limitToRings = 
	[
		"AIRingType.Extreme"
	];
	coversWithLOS = 1;
}

ValidCoversExtreme : AIValidCoversCond
{
	limitToRings = 
	[
		"AIRingType.Extreme"
	];
}

ValidCoversMediumFarExtreme : AIValidCoversCond
{
	limitToRings = 
	[
		"AIRingType.Medium", "AIRingType.Far", "AIRingType.Extreme"
	];
}

NotValidCoversWithLOSCurrentRing : ValidCoversWithLOSCurrentRing
{
	invert = true;
}

ValidCoversWithLOSCurrentRing : AIValidCoversCond
{
	checkCurrentlyActiveRing = true;
	coversWithLOS = 1;
}

NotValidCoversWithoutLOSCurrentRing : ValidCoversWithoutLOSCurrentRing
{
	invert = true;
}

ValidCoversWithoutLOSCurrentRing : AIValidCoversCond
{
	checkCurrentlyActiveRing = true;
	coversWithLOS = 0;
}

NotValidCoversCurrentRing : ValidCoversCurrentRing
{
	invert = true;
}

ValidCoversCurrentRing : AIValidCoversCond
{
	checkCurrentlyActiveRing = true;
}

NotValidCovers : AIValidCoversCond
{
	invert = true;
}

ValidCovers : AIValidCoversCond
{
}

NotTargetInRestrictedMovementArea : TargetInRestrictedMovementArea
{
	invert = true;
}

TargetInRestrictedMovementArea : AIRestrictedMovementAreaCond
{
	target = "AIActionTarget.CombatTarget";
}

NotPlayerInRestrictedMovementArea : PlayerInRestrictedMovementArea
{
	invert = true;
}

PlayerInRestrictedMovementArea : AIRestrictedMovementAreaCond
{
	target = "AIActionTarget.Player";
}

NotStimSourceInRestrictedMovementArea : StimSourceInRestrictedMovementArea
{
	invert = true;
}

StimSourceInRestrictedMovementArea : AIRestrictedMovementAreaCond
{
	target = "AIActionTarget.StimSource";
}

NotStimTargetInRestrictedMovementArea : StimTargetInRestrictedMovementArea
{
	invert = true;
}

StimTargetInRestrictedMovementArea : AIRestrictedMovementAreaCond
{
	target = "AIActionTarget.StimTarget";
}

NotNearestSquadmateInRestrictedMovementArea : NearestSquadmateInRestrictedMovementArea
{
	invert = true;
}

NearestSquadmateInRestrictedMovementArea : AIRestrictedMovementAreaCond
{
	target = "AIActionTarget.NearestSquadmate";
}

NotInRestrictedMovementArea : InRestrictedMovementArea
{
	invert = true;
}

InRestrictedMovementArea : AIRestrictedMovementAreaCond
{
	target = "AIActionTarget.Owner";
}

NotStimTargetIsTresspassing : StimTargetIsTresspassing
{
	invert = true;
}

StimTargetIsTresspassing : AITresspassingCond
{
	target = "AIActionTarget.StimTarget";
}

NotInSafeZone : InSafeZone
{
	invert = true;
}

InSafeZone : AITresspassingCond
{
	target = "AIActionTarget.Owner";
	checkSafeArea = true;
}

NotTargetInSafeZone : TargetInSafeZone
{
	invert = true;
}

TargetInSafeZone : AITresspassingCond
{
	target = "AIActionTarget.CombatTarget";
	checkSafeArea = true;
}

NotPlayerInSafeZone : PlayerInSafeZone
{
	invert = true;
}

PlayerInSafeZone : AITresspassingCond
{
	target = "AIActionTarget.Player";
	checkSafeArea = true;
}

TargetBelow0dot2m : AISpatialCond
{
	distance = ( -1.f, 0.2f );
}

TargetAbove0dot2m : AISpatialCond
{
	distance = ( 0.2f, -1.f );
}

TargetBelow1m : AISpatialCond
{
	distance = ( -1.f, 1.f );
}

TargetAbove1m : AISpatialCond
{
	distance = ( 1.f, -1.f );
}

TargetBelow1dot3m : AISpatialCond
{
	distance = ( -1.f, 1.3f );
}

TargetBelow1dot5m : AISpatialCond
{
	distance = ( -1.f, 1.5f );
}

TargetBelow1dot5mPrediction : AISpatialCond
{
	distance = ( -1.f, 1.5f );
	predictionTime = 0.14f;
}

TargetAbove1dot5m : AISpatialCond
{
	distance = ( 1.5f, -1.f );
}

TargetBelow2m : AISpatialCond
{
	distance = ( -1.f, 2.f );
}

TargetAbove2m : AISpatialCond
{
	distance = ( 2.f, -1.f );
}

TargetItemBelow2m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( -1.f, 2.f );
}

TargetItemAbove2m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( 2.f, -1.f );
}

TargetBelow2mPrediction : AISpatialCond
{
	distance = ( -1.f, 2.f );
	predictionTime = 0.14f;
}

TargetAbove2mPrediction : AISpatialCond
{
	distance = ( 2.f, -1.f );
	predictionTime = 0.14f;
}

TargetBelow2dot5m : AISpatialCond
{
	distance = ( -1.f, 2.5f );
}

TargetAbove2dot5m : AISpatialCond
{
	distance = ( 2.5f, -1.f );
}

TargetBelow2dot5mPrediction : AISpatialCond
{
	distance = ( -1.f, 2.5f );
	predictionTime = 0.14f;
}

TargetAbove2dot5mPrediction : AISpatialCond
{
	distance = ( 2.5f, -1.f );
	predictionTime = 0.14f;
}

TargetBelow3mPrediction : AISpatialCond
{
	distance = ( -1.f, 3.f );
	predictionTime = 0.14f;
}

TargetAbove3mPrediction : AISpatialCond
{
	distance = ( 3.f, -1.f );
	predictionTime = 0.14f;
}

TargetBelow3mLongPrediction : AISpatialCond
{
	distance = ( -1.f, 3.f );
	predictionTime = 0.5f;
}

TargetAbove3mLongPrediction : AISpatialCond
{
	distance = ( 3.f, -1.f );
	predictionTime = 0.5f;
}

TargetBelow3m : AISpatialCond
{
	distance = ( -1.f, 3.f );
}

TargetAbove3m : AISpatialCond
{
	distance = ( 3.f, -1.f );
}

TargetItemBelow3m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( -1.f, 3.f );
}

TargetItemAbove3m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( 3.f, -1.f );
}

TargetBelow3dot5m : AISpatialCond
{
	distance = ( -1.f, 3.5f );
}

TargetAbove3dot5m : AISpatialCond
{
	distance = ( 3.5f, -1.f );
}

TargetBelow3dot8m : AISpatialCond
{
	distance = ( -1.f, 3.8f );
}

TargetAbove3dot8m : AISpatialCond
{
	distance = ( 3.8f, -1.f );
}

TargetBelow4m : AISpatialCond
{
	distance = ( -1.f, 4.f );
}

TargetAbove4m : AISpatialCond
{
	distance = ( 4.f, -1.f );
}

TargetBelow4mPrediction : AISpatialCond
{
	distance = ( -1.f, 4.f );
	predictionTime = 0.14f;
}

TargetAbove4mPrediction : AISpatialCond
{
	distance = ( 4.f, -1.f );
	predictionTime = 0.14f;
}

TargetBelow4dot5m : AISpatialCond
{
	distance = ( -1.f, 4.5f );
}

TargetAbove4dot5m : AISpatialCond
{
	distance = ( 4.5f, -1.f );
}

NotTargetBelow5m : TargetBelow5m
{
	invert = true;
}

TargetBelow5m : AISpatialCond
{
	distance = ( -1.f, 5.f );
}

TargetAbove5m : AISpatialCond
{
	distance = ( 5.f, -1.f );
}

TargetItemBelow5m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( -1.f, 5.f );
}

TargetItemAbove5m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( 5.f, -1.f );
}

TargetBelow5mPrediction : AISpatialCond
{
	distance = ( -1.f, 5.f );
	predictionTime = 0.14f;
}

TargetAbove5mPrediction : AISpatialCond
{
	distance = ( 5.f, -1.f );
	predictionTime = 0.14f;
}

TargetBelow6m : AISpatialCond
{
	distance = ( -1.f, 6.f );
}

TargetAbove6m : AISpatialCond
{
	distance = ( 6.f, -1.f );
}

TargetAbove6mPrediction : AISpatialCond
{
	distance = ( 6.f, -1.f );
	predictionTime = 0.14f;
}

TargetBelow7m : AISpatialCond
{
	distance = ( -1.f, 7.f );
}

TargetAbove7m : AISpatialCond
{
	distance = ( 7.f, -1.f );
}

TargetBelow7dot5mPrediction : AISpatialCond
{
	distance = ( -1f, 7.5f );
	predictionTime = 0.5f;
}

TargetAbove7dot5mPrediction : AISpatialCond
{
	distance = ( 7.5f, -1.f );
	predictionTime = 0.25f;
}

TargetAbove7dot5m : AISpatialCond
{
	distance = ( 7.5f, -1.f );
}

TargetBelow7dot5m : AISpatialCond
{
	distance = ( -1f, 7.5f );
	predictionTime = 0.5f;
}

TargetAbove7mLongPrediction : AISpatialCond
{
	distance = ( 7.f, -1.f );
	predictionTime = 0.5f;
}

TargetBelow7mLongPrediction : AISpatialCond
{
	distance = ( -1.f, 7.f );
	predictionTime = 0.5f;
}

TargetBelow8m : AISpatialCond
{
	distance = ( -1.f, 8.f );
}

TargetAbove8m : AISpatialCond
{
	distance = ( 8.f, -1.f );
}

TargetBelow8mPrediction : AISpatialCond
{
	distance = ( -1.f, 8.f );
	predictionTime = 0.14f;
}

TargetAbove8mPrediction : AISpatialCond
{
	distance = ( 8.f, -1.f );
	predictionTime = 0.14f;
}

TargetItemBelow8m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( -1.f, 8.f );
}

TargetItemAbove8m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( 8.f, -1.f );
}

TargetBelow9m : AISpatialCond
{
	distance = ( -1.f, 9.f );
}

TargetAbove9m : AISpatialCond
{
	distance = ( 9.f, -1.f );
}

TargetBelow10m : AISpatialCond
{
	distance = ( -1.f, 10.f );
}

TargetAbove10m : AISpatialCond
{
	distance = ( 10.f, -1.f );
}

TargetAbove10mPrediction : AISpatialCond
{
	distance = ( 10.f, -1.f );
	predictionTime = 0.5f;
}

TargetAbove11m : AISpatialCond
{
	distance = ( 11.f, -1.f );
}

TargetBelow12m : AISpatialCond
{
	distance = ( -1.f, 12.f );
}

TargetAbove12m : AISpatialCond
{
	distance = ( 12.f, -1.f );
}

TargetAbove12mPrediction : AISpatialCond
{
	distance = ( 12.f, -1.f );
	predictionTime = 0.5f;
}

TargetBelow13m : AISpatialCond
{
	distance = ( -1.f, 13.f );
}

TargetAbove13m : AISpatialCond
{
	distance = ( 13.f, -1.f );
}

TargetBelow15m : AISpatialCond
{
	distance = ( -1.f, 15.f );
}

TargetAbove15m : AISpatialCond
{
	distance = ( 15.f, -1.f );
}

TargetAbove15mPrediction : AISpatialCond
{
	distance = ( 15.f, -1.f );
	predictionTime = 0.5f;
}

TargetBelow18m : AISpatialCond
{
	distance = ( -1.f, 18.f );
}

TargetAbove18m : AISpatialCond
{
	distance = ( 18.f, -1.f );
}

TargetAbove20m : AISpatialCond
{
	distance = ( 20.f, -1.f );
}

TargetBelow20m : AISpatialCond
{
	distance = ( -1.f, 20.f );
}

TargetBelow25m : AISpatialCond
{
	distance = ( -1.f, 25.f );
}

TargetAbove25m : AISpatialCond
{
	distance = ( 25.f, -1.f );
}

TargetBelow30m : AISpatialCond
{
	distance = ( -1.f, 30.f );
}

TargetAbove30m : AISpatialCond
{
	distance = ( 30.f, -1.f );
}

TargetBelow50m : AISpatialCond
{
	distance = ( -1.f, 50.f );
}

TargetAbove50m : AISpatialCond
{
	distance = ( 50.f, -1.f );
}

TargetBelow60m : AISpatialCond
{
	distance = ( -1.f, 60.f );
}

TargetAbove60m : AISpatialCond
{
	distance = ( 60.f, -1.f );
}

TargetBelow70m : AISpatialCond
{
	distance = ( -1.f, 70.f );
}

TargetAbove70m : AISpatialCond
{
	distance = ( 70.f, -1.f );
}

CurrentCoverAbove0m : AISpatialCond
{
	distance = ( 0.1f, -1.f );
}

TargetBetween3and6m : AISpatialCond
{
	distance = ( 3.f, 6.f );
}

TargetBetween15and25m : AISpatialCond
{
	distance = ( 15.f, 25.f );
}

TargetBetween10and30m : AISpatialCond
{
	distance = ( 10.f, 30.f );
}

TargetBetween9and11m : AISpatialCond
{
	distance = ( 9.f, 11.f );
}

TargetBetween9and37m : AISpatialCond
{
	distance = ( 9.f, 37.f );
}

TargetBetween2dot9and5dot1m : AISpatialCond
{
	distance = ( 2.9f, 5.1f );
}

MovementDestinationAbove0Dot1m : AISpatialCond
{
	target = "AIActionTarget.MovementDestination";
	distance = ( 0.1f, -1.f );
}

MovementDestinationBelow0Dot1m : AISpatialCond
{
	target = "AIActionTarget.MovementDestination";
	distance = ( -1.f, 0.1f );
}

MovementDestinationAbove1m : AISpatialCond
{
	target = "AIActionTarget.MovementDestination";
	distance = ( 1.f, -1.f );
}

MovementDestinationBelow1m : AISpatialCond
{
	target = "AIActionTarget.MovementDestination";
	distance = ( -1.f, 1.f );
}

MovementDestinationAbove3m : AISpatialCond
{
	target = "AIActionTarget.MovementDestination";
	distance = ( 3.f, -1.f );
}

MovementDestinationBelow3m : AISpatialCond
{
	target = "AIActionTarget.MovementDestination";
	distance = ( -1.f, 3.f );
}

CustomWorldPositionBelow3m : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	distance = ( -1.f, 3.f );
}

CustomWorldPositionBelow4m : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	distance = ( -1.f, 4.f );
}

CustomWorldPositionBelow5m : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	distance = ( -1.f, 5.f );
}

CustomWorldPositionAbove2m : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	distance = ( 2.f, -1.f );
}

CustomWorldPositionAbove3m : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	distance = ( 3.f, -1.f );
}

CustomWorldPositionBelow15deg : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	coneAngle = ( -1.f, 15.f );
}

CustomWorldPositionAbove25deg : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	coneAngle = ( 25.f, -1.f );
}

FollowerAbove3dot7zDiff : AISpatialCond
{
	zDiff = ( 3.7f, -1.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove3mNoHints : AISpatialCond
{
	distance = ( 3.f, -1.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow3mNoHints : AISpatialCond
{
	distance = ( -1.f, 3.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove4m : AISpatialCond
{
	distance = ( 4.f, -1.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow4m : AISpatialCond
{
	distance = ( -1.f, 4.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove5m : AISpatialCond
{
	distance = ( 5.f, -1.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow5m : AISpatialCond
{
	distance = ( -1.f, 5.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove6m : AISpatialCond
{
	distance = ( 6.f, -1.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow6m : AISpatialCond
{
	distance = ( -1.f, 6.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove9m : AISpatialCond
{
	distance = ( 9.f, -1.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow9m : AISpatialCond
{
	distance = ( -1.f, 9.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove10m : AISpatialCond
{
	distance = ( 10.f, -1.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow10m : AISpatialCond
{
	distance = ( -1.f, 10.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove10mNoHints : AISpatialCond
{
	distance = ( 10.f, -1.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow10mNoHints : AISpatialCond
{
	distance = ( -1.f, 10.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove16mNoHints : AISpatialCond
{
	distance = ( 17.f, -1.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow16mNoHints : AISpatialCond
{
	distance = ( -1.f, 17.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove17m : AISpatialCond
{
	distance = ( 17.f, -1.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow17m : AISpatialCond
{
	distance = ( -1.f, 17.f );
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove20mNoHints : AISpatialCond
{
	distance = ( 20.f, -1.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow20mNoHints : AISpatialCond
{
	distance = ( -1.f, 20.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove40deg : AISpatialCond
{
	coneAngle = ( 40.f, -1.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow40deg : AISpatialCond
{
	coneAngle = ( -1.f, 40.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerPOVBelow90deg : AISpatialCond
{
	coneAngle = ( -1.f, 90.f );
	useTargetPOV = true;
	target = "AIActionTarget.FriendlyTarget";
}

FollowerPOVAbove90deg : AISpatialCond
{
	coneAngle = ( 90.f, -1.f );
	useTargetPOV = true;
	target = "AIActionTarget.FriendlyTarget";
}

FollowerPOVBelow120deg : AISpatialCond
{
	coneAngle = ( -1.f, 120.f );
	useTargetPOV = true;
	target = "AIActionTarget.FriendlyTarget";
}

FollowerPOVAbove120deg : AISpatialCond
{
	coneAngle = ( 120.f, -1.f );
	useTargetPOV = true;
	target = "AIActionTarget.FriendlyTarget";
}

FollowerBelow180deg : AISpatialCond
{
	coneAngle = ( -1.f, 180.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerAbove180deg : AISpatialCond
{
	coneAngle = ( 180.f, -1.f );
	target = "AIActionTarget.FriendlyTarget";
}

FollowerPOVBelow180deg : AISpatialCond
{
	coneAngle = ( -1.f, 180.f );
	useTargetPOV = true;
	target = "AIActionTarget.FriendlyTarget";
}

FollowerPOVAbove180deg : AISpatialCond
{
	coneAngle = ( 180.f, -1.f );
	useTargetPOV = true;
	target = "AIActionTarget.FriendlyTarget";
}

FollowerPOVBelow225deg : AISpatialCond
{
	coneAngle = ( -1.f, 225.f );
	useTargetPOV = true;
	target = "AIActionTarget.FriendlyTarget";
}

FollowerPOVAbove225deg : AISpatialCond
{
	coneAngle = ( 225.f, -1.f );
	useTargetPOV = true;
	target = "AIActionTarget.FriendlyTarget";
}

FollowerPOVBelow270deg : AISpatialCond
{
	coneAngle = ( -1.f, 270.f );
	useTargetPOV = true;
	target = "AIActionTarget.FriendlyTarget";
}

FollowerPOVAbove270deg : AISpatialCond
{
	coneAngle = ( 270.f, -1.f );
	useTargetPOV = true;
	target = "AIActionTarget.FriendlyTarget";
}

TargetPOVBelow20degRightLongPrediction : AISpatialCond
{
	coneAngle = ( -1.f, 20.f );
	angleDirection = 1;
	predictionTime = 0.3f;
	useTargetPOV = true;
}

TargetPOVBelow45degRight : AISpatialCond
{
	coneAngle = ( -1.f, 45.f );
	angleDirection = 1;
	useTargetPOV = true;
}

TargetPOVBelow45degRightLongPrediction : AISpatialCond
{
	coneAngle = ( -1.f, 45.f );
	angleDirection = 1;
	predictionTime = 0.3f;
	useTargetPOV = true;
}

TargetPOVAbove45degRight : AISpatialCond
{
	coneAngle = ( 45.f, -1.f );
	angleDirection = 1;
	useTargetPOV = true;
}

TargetPOVAbove45degRightLongPrediction : AISpatialCond
{
	coneAngle = ( 45.f, -1.f );
	angleDirection = 1;
	predictionTime = 0.3f;
	useTargetPOV = true;
}

TargetPOVBelow60degRight : AISpatialCond
{
	coneAngle = ( -1.f, 60.f );
	angleDirection = 1;
	useTargetPOV = true;
}

TargetPOVAbove60degRight : AISpatialCond
{
	coneAngle = ( 60.f, -1.f );
	angleDirection = 1;
	useTargetPOV = true;
}

TargetPOVAbove75degRight : AISpatialCond
{
	coneAngle = ( 75.f, -1.f );
	angleDirection = 1;
	useTargetPOV = true;
}

TargetPOVBelow75degRightLongPrediction : AISpatialCond
{
	coneAngle = ( -1.f, 75.f );
	angleDirection = 1;
	predictionTime = 0.3f;
	useTargetPOV = true;
}

TargetPOVAbove80degRight : AISpatialCond
{
	coneAngle = ( 80.f, -1.f );
	angleDirection = 1;
	useTargetPOV = true;
}

TargetPOVBelow90degRight : AISpatialCond
{
	coneAngle = ( -1.f, 90.f );
	angleDirection = 1;
	useTargetPOV = true;
}

TargetPOVAbove25degRightLongPrediction : AISpatialCond
{
	coneAngle = ( 25.f, -1.f );
	angleDirection = 1;
	predictionTime = 0.3f;
	useTargetPOV = true;
}

TargetPOVBelow10degRight : AISpatialCond
{
	coneAngle = ( -1.f, 10.f );
	angleDirection = 1;
	useTargetPOV = true;
}

TargetPOVRight : AISpatialCond
{
	angleDirection = 1;
	useTargetPOV = true;
}

TargetRight : AISpatialCond
{
	angleDirection = 1;
}

CustomWorldPositionRight : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	angleDirection = 1;
}

TargetPOVAbove25degLeftLongPrediction : AISpatialCond
{
	coneAngle = ( 25.f, -1.f );
	angleDirection = -1;
	predictionTime = 0.3f;
	useTargetPOV = true;
}

TargetPOVBelow20degLeftLongPrediction : AISpatialCond
{
	coneAngle = ( -1.f, 20.f );
	angleDirection = -1;
	predictionTime = 0.3f;
	useTargetPOV = true;
}

TargetPOVBelow45degLeft : AISpatialCond
{
	coneAngle = ( -1.f, 45.f );
	angleDirection = -1;
	useTargetPOV = true;
}

TargetPOVBelow45degLeftLongPrediction : AISpatialCond
{
	coneAngle = ( -1.f, 45.f );
	angleDirection = -1;
	predictionTime = 0.3f;
	useTargetPOV = true;
}

TargetPOVAbove45degLeft : AISpatialCond
{
	coneAngle = ( 45.f, -1.f );
	angleDirection = -1;
	useTargetPOV = true;
}

TargetPOVAbove45degLeftLongPrediction : AISpatialCond
{
	coneAngle = ( 45.f, -1.f );
	angleDirection = -1;
	predictionTime = 0.3f;
	useTargetPOV = true;
}

TargetPOVBelow60degLeft : AISpatialCond
{
	coneAngle = ( -1.f, 60.f );
	angleDirection = -1;
	useTargetPOV = true;
}

TargetPOVAbove60degLeft : AISpatialCond
{
	coneAngle = ( 60.f, -1.f );
	angleDirection = -1;
	useTargetPOV = true;
}

TargetPOVAbove75degLeft : AISpatialCond
{
	coneAngle = ( 75.f, -1.f );
	angleDirection = -1;
	useTargetPOV = true;
}

TargetPOVBelow75degLeftLongPrediction : AISpatialCond
{
	coneAngle = ( -1.f, 75.f );
	angleDirection = -1;
	predictionTime = 0.3f;
	useTargetPOV = true;
}

TargetPOVAbove80degLeft : AISpatialCond
{
	coneAngle = ( 80.f, -1.f );
	angleDirection = -1;
	useTargetPOV = true;
}

TargetPOVBelow90degLeft : AISpatialCond
{
	coneAngle = ( -1.f, 90.f );
	angleDirection = -1;
	useTargetPOV = true;
}

TargetPOVBelow10degLeft : AISpatialCond
{
	coneAngle = ( -1.f, 10.f );
	angleDirection = -1;
	useTargetPOV = true;
}

TargetPOVLeft : AISpatialCond
{
	angleDirection = -1;
	useTargetPOV = true;
}

TargetLeft : AISpatialCond
{
	angleDirection = -1;
}

CustomWorldPositionLeft : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	angleDirection = -1;
}

TargetBelow10deg : AISpatialCond
{
	coneAngle = ( -1.f, 10.f );
}

TargetAbove10deg : AISpatialCond
{
	coneAngle = ( 10.f, -1.f );
}

TargetPOVBelow10deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 10.f );
}

TargetPOVBelow15deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 15.f );
}

TargetPOVAbove15deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( 15.f, -1.f );
}

TargetBelow15deg : AISpatialCond
{
	coneAngle = ( -1.f, 15.f );
}

TargetPOVAbove25deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( 25.f, -1.f );
}

TargetPOVAbove30deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( 30.f, -1.f );
}

TargetPOVBelow30deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 30.f );
}

TargetBelow35deg : AISpatialCond
{
	coneAngle = ( -1.f, 35.f );
}

TargetAbove35deg : AISpatialCond
{
	coneAngle = ( 35.f, -1 );
}

TargetBelow45deg : AISpatialCond
{
	coneAngle = ( -1.f, 45.f );
}

TargetPOVBelow45deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 45.f );
}

TargetAbove45deg : AISpatialCond
{
	coneAngle = ( 45.f, -1.f );
}

TargetPOVBelow50deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 50.f );
}

TargetBelow60deg : AISpatialCond
{
	coneAngle = ( -1.f, 60.f );
}

TargetPOVBelow60deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 60.f );
}

TargetPOVAbove60deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( 60.f, -1.f );
}

TargetBelow75deg : AISpatialCond
{
	coneAngle = ( -1.f, 75.f );
}

TargetPOVBelow75deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 75.f );
}

TargetAbove80deg : AISpatialCond
{
	coneAngle = ( 80.f, -1.f );
}

TargetPOVAbove80degLongPrediction : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( 80.f, -1.f );
	predictionTime = 0.3f;
}

TargetPOVBelow90deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 90.f );
}

TargetPOVAbove90deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( 90.f, -1.f );
}

TargetBelow90deg : AISpatialCond
{
	coneAngle = ( -1.f, 90.f );
}

TargetAbove90deg : AISpatialCond
{
	coneAngle = ( 90.f, -1.f );
}

CustomWorldPositiontBelow90deg : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	coneAngle = ( -1.f, 90.f );
}

CustomWorldPositiontAbove90deg : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	coneAngle = ( 90.f, -1.f );
}

TargetStimBelow90deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( -1.f, 90.f );
}

TargetStimAbove90deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 90.f, -1.f );
}

TargetItemBelow90deg : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	coneAngle = ( -1.f, 90.f );
}

TargetItemAbove90deg : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	coneAngle = ( 90.f, -1.f );
}

TargetPOVBelow120deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 120.f );
}

TargetPOVAbove120deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( 120.f, -1.f );
}

TargetBelow120deg : AISpatialCond
{
	coneAngle = ( -1.f, 120.f );
}

TargetAbove120deg : AISpatialCond
{
	coneAngle = ( 120.f, -1.f );
}

TopThreatBelow120deg : AISpatialCond
{
	target = "AIActionTarget.TopThreat";
	coneAngle = ( -1.f, 120.f );
}

TopThreatAbove120deg : AISpatialCond
{
	target = "AIActionTarget.TopThreat";
	coneAngle = ( 120.f, -1.f );
}

TargetBelow140deg : AISpatialCond
{
	coneAngle = ( -1.f, 140.f );
}

TargetAbove140deg : AISpatialCond
{
	coneAngle = ( 140.f, -1.f );
}

TargetPOVBelow140deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 140.f );
}

TargetPOVAbove140deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( 140.f, -1.f );
}

TargetBelow180deg : AISpatialCond
{
	coneAngle = ( -1.f, 180.f );
}

TargetAbove180deg : AISpatialCond
{
	coneAngle = ( 180.f, -1.f );
}

TargetPOVBelow180deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 180.f );
}

TargetPOVAbove180deg : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( 180.f, -1.f );
}

TargetBelow225deg : AISpatialCond
{
	coneAngle = ( -1.f, 225.f );
}

TargetAbove225deg : AISpatialCond
{
	coneAngle = ( 225.f, -1.f );
}

TargetBelow270deg : AISpatialCond
{
	coneAngle = ( -1.f, 270.f );
}

TargetAbove270deg : AISpatialCond
{
	coneAngle = ( 270.f, -1.f );
}

TargetBetween120and270deg : AISpatialCond
{
	coneAngle = ( 120.f, 270.f );
}

TargetBack : AISpatialCond
{
	coneAngle = ( 270.f, 360.f );
}

SelectedCoverAbove3m : AISpatialCond
{
	distance = ( 3.f, -1.f );
	target = "AIActionTarget.SelectedCover";
}

SelectedCoverBelow180deg : AISpatialCond
{
	coneAngle = ( -1.f, 180.f );
	target = "AIActionTarget.SelectedCover";
}

SelectedCoverToTargetBelow7m : AISpatialCond
{
	distance = ( -1.f, 7.f );
	source = "AIActionTarget.SelectedCover";
}

SelectedCoverToTargetAbove7m : AISpatialCond
{
	distance = ( 7.f, -1.f );
	source = "AIActionTarget.SelectedCover";
}

SelectedCoverToTargetBelow9m : AISpatialCond
{
	distance = ( -1.f, 9.f );
	source = "AIActionTarget.SelectedCover";
}

SelectedCoverToTargetAbove9m : AISpatialCond
{
	distance = ( 9.f, -1.f );
	source = "AIActionTarget.SelectedCover";
}

SelectedCoverToTargetAbove12m : AISpatialCond
{
	distance = ( 12.f, -1.f );
	source = "AIActionTarget.SelectedCover";
}

SelectedCoverToTargetAbove15m : AISpatialCond
{
	distance = ( 15.f, -1.f );
	source = "AIActionTarget.SelectedCover";
}

TargetToOptSelectedCoverBelow160deg : AISpatialCond
{
	coneAngle = ( -1.f, 160.f );
	targetOpt = "AIActionTarget.SelectedCover";
}

TargetUpTo1dot4mZDiff : AISpatialCond
{
	zDiff = ( 0.f, 1.4f );
}

TargetUpTo2dot5mZDiff : AISpatialCond
{
	zDiff = ( 0.f, 2.5f );
}

PlayerUpTo1dot4mZDiffFromCombatTarget : AISpatialCond
{
	zDiff = ( 0.f, 1.4f );
	source = "AIActionTarget.Player";
	target = "AIActionTarget.CombatTarget";
}

TargetUpTo1mZDiffFromCombatTarget : AISpatialCond
{
	zDiff = ( 0.f, 1.f );
	target = "AIActionTarget.CombatTarget";
}

TargetUpTo0dot5mZDiff : AISpatialCond
{
	zDiff = ( 0.f, 0.5f );
}

TargetUpTo3dot5mZDiff : AISpatialCond
{
	zDiff = ( 0.f, 3.5f );
}

TargetUpTo6dot5mZDiff : AISpatialCond
{
	zDiff = ( 0.f, 6.5f );
}

TargetAbove1dot4mZDiff : AISpatialCond
{
	zDiff = ( 1.4f, 0.f );
}

TargetAbove2dot5mZDiff : AISpatialCond
{
	zDiff = ( 2.f, 0.f );
}

TargetAbove3mZDiff : AISpatialCond
{
	zDiff = ( 2.5f, 0.f );
}

TargetAbove5mZDiff : AISpatialCond
{
	zDiff = ( 5.f, 0.f );
}

NearestSquadmateRight : AISpatialCond
{
	target = "AIActionTarget.NearestSquadmate";
	angleDirection = 1;
}

NearestSquadmateLeft : AISpatialCond
{
	target = "AIActionTarget.NearestSquadmate";
	angleDirection = -1;
}

NearestSquadmateBelow0dot7m : AISpatialCond
{
	distance = ( -1.f, 0.7f );
	target = "AIActionTarget.NearestSquadmate";
}

NearestSquadmateBelow1m : AISpatialCond
{
	distance = ( -1.f, 1.f );
	target = "AIActionTarget.NearestSquadmate";
}

NearestSquadmateBelow1dot5m : AISpatialCond
{
	distance = ( -1.f, 1.5f );
	target = "AIActionTarget.NearestSquadmate";
}

NearestSquadmateBelow3m : AISpatialCond
{
	distance = ( -1.f, 3.f );
	target = "AIActionTarget.NearestSquadmate";
}

NearestSquadmateBelow4m : AISpatialCond
{
	distance = ( -1.f, 4.5f );
	target = "AIActionTarget.NearestSquadmate";
}

NearestSquadmateBelow10m : AISpatialCond
{
	distance = ( -1.f, 10.f );
	target = "AIActionTarget.NearestSquadmate";
}

NearestSquadmateBelow15m : AISpatialCond
{
	distance = ( -1.f, 15.f );
	target = "AIActionTarget.NearestSquadmate";
}

NearestSquadmateAbove0dot1m : AISpatialCond
{
	distance = ( 0.1f, -1f );
	target = "AIActionTarget.NearestSquadmate";
}

NearestSquadmateAbove3m : AISpatialCond
{
	distance = ( 3.0f, -1f );
	target = "AIActionTarget.NearestSquadmate";
}

NearestSquadmateNotBelow6m : AISpatialCond
{
	invert = true;
	target = "AIActionTarget.NearestSquadmate";
	distance = ( -1.f, 6.f );
}

NearestDefeatedSquadmateBelow1m : AISpatialCond
{
	target = "AIActionTarget.NearestDefeatedSquadmate";
	distance = ( -1.f, 1.f );
}

NearestDefeatedSquadmateBelow120deg : AISpatialCond
{
	target = "AIActionTarget.NearestDefeatedSquadmate";
	coneAngle = ( -1.f, 120.f );
}

InFrontOfNearestSquadmate : AISpatialCond
{
	useTargetPOV = true;
	coneAngle = ( -1.f, 7.f );
	target = "AIActionTarget.NearestSquadmate";
}

FurthestSquadmateBelow3m : AISpatialCond
{
	distance = ( -1.f, 3.f );
	target = "AIActionTarget.FurthestSquadmate";
}

FurthestSquadmateAbove5m : AISpatialCond
{
	distance = ( 5.f, -1.f );
	target = "AIActionTarget.FurthestSquadmate";
}

FurthestSquadmateRight : AISpatialCond
{
	angleDirection = 1;
	target = "AIActionTarget.FurthestSquadmate";
}

FurthestSquadmateLeft : AISpatialCond
{
	angleDirection = -1;
	target = "AIActionTarget.FurthestSquadmate";
}

NotFurthestSquadmateBelow15deg : FurthestSquadmateBelow15deg
{
	invert = true;
}

FurthestSquadmateBelow15deg : AISpatialCond
{
	target = "AIActionTarget.FurthestSquadmate";
	coneAngle = ( -1.f, 15.f );
}

NearestSquadmate1point8High : AISpatialCond
{
	target = "AIActionTarget.NearestSquadmate";
	zDiff = ( 1.8f, -1.f );
}

NearestSquadmate0point4Low : AISpatialCond
{
	target = "AIActionTarget.NearestSquadmate";
	zDiff = ( 0.f, 0.4f );
}

CurrentCoverToTargetBelow4mPrediction : AISpatialCond
{
	distance = ( -1.f, 4.f );
	predictionTime = 0.73f;
	source = "AIActionTarget.CurrentCover";
}

CurrentCoverToTargetAbove4mPrediction : AISpatialCond
{
	distance = ( 4.f, -1.f );
	predictionTime = 0.73f;
	source = "AIActionTarget.CurrentCover";
}

CurrentCoverToTargetBelow7mPrediction : AISpatialCond
{
	distance = ( -1.f, 7.f );
	predictionTime = 0.73f;
	source = "AIActionTarget.CurrentCover";
}

CurrentCoverToTargetAbove7mPrediction : AISpatialCond
{
	distance = ( 7.f, -1.f );
	predictionTime = 0.73f;
	source = "AIActionTarget.CurrentCover";
}

CommandCoverToTargetBelow4mPrediction : AISpatialCond
{
	distance = ( -1.f, 4.f );
	predictionTime = 0.73f;
	source = "AIActionTarget.CommandCover";
}

CommandCoverToTargetAbove4mPrediction : AISpatialCond
{
	distance = ( 4.f, -1.f );
	predictionTime = 0.73f;
	source = "AIActionTarget.CommandCover";
}

CommandCoverToTargetAbove25m : AISpatialCond
{
	distance = ( 25.f, -1.f );
	source = "AIActionTarget.CommandCover";
}

TargetBelow9mPrediction : AISpatialCond
{
	distance = ( -1.f, 9.f );
	predictionTime = 0.511f;
}

TargetAbove9mPrediction : AISpatialCond
{
	distance = ( 9.f, -1.f );
	predictionTime = 0.511f;
}

CurrentCoverToTargetBelow9mPrediction : AISpatialCond
{
	distance = ( -1.f, 9.f );
	predictionTime = 0.73f;
	source = "AIActionTarget.CurrentCover";
}

CurrentCoverToTargetAbove9mPrediction : AISpatialCond
{
	distance = ( 9.f, -1.f );
	predictionTime = 0.73f;
	source = "AIActionTarget.CurrentCover";
}

StimTargetBelow1point5m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( -1f, 1.5f );
}

StimTargetBelow1m : AISpatialCond
{
	distance = ( -1.f, 1.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetBelow2m : AISpatialCond
{
	distance = ( -1.f, 2.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetBelow2point5m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( -1f, 2.5f );
}

StimTargetBelow3m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( -1.f, 3.f );
}

StimTargetBelow3point5m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( -1.f, 3.5f );
}

StimTargetBelow4m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( -1.f, 4.f );
}

StimTargetBelow5m : AISpatialCond
{
	distance = ( -1.f, 5.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetBelow6m : AISpatialCond
{
	distance = ( -1.f, 6.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetBelow8m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( -1f, 8f );
}

StimTargetBelow12m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( -1f, 12f );
}

StimTargetBelow15m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( -1f, 15f );
}

StimTargetBelow40m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( -1f, 40f );
}

StimTargetAbove3m : AISpatialCond
{
	distance = ( 3.f, -1.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetAbove4m : AISpatialCond
{
	distance = ( 4.f, -1.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetAbove5m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( 5.f, -1.f );
}

StimTargetAbove6m : AISpatialCond
{
	distance = ( 6.f, -1.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetAbove9m : AISpatialCond
{
	distance = ( 9.f, -1.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetAbove10m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( 10.f, -1.f );
}

StimTargetAbove12m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( 12.f, -1.f );
}

StimTargetAbove15m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( 15.f, -1.f );
}

StimTargetAbove20m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( 20.f, -1.f );
}

StimTargetAbove40m : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( 40.f, -1.f );
}

StimSource : AISpatialCond
{
	target = "AIActionTarget.StimSource";
}

StimSourceBelow1m : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	distance = ( -1, 1.f );
}

StimSourceBelow1dot5m : AISpatialCond
{
	distance = ( -1.f, 1.5f );
	target = "AIActionTarget.StimSource";
}

StimSourceBelow2dot5m : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	distance = ( -1, 2.5f );
}

StimSourceBelow4m : AISpatialCond
{
	distance = ( -1.f, 4.f );
	target = "AIActionTarget.StimSource";
}

StimSourceBelow5m : AISpatialCond
{
	distance = ( -1.f, 5.f );
	target = "AIActionTarget.StimSource";
}

StimSourceAbove2m : AISpatialCond
{
	distance = ( 2.f, -1.f );
	target = "AIActionTarget.StimSource";
}

StimSourceAbove4m : AISpatialCond
{
	distance = ( 4.f, -1.f );
	target = "AIActionTarget.StimSource";
}

StimSourceAbove6m : AISpatialCond
{
	distance = ( 6.f, -1.f );
	target = "AIActionTarget.StimSource";
}

StimSourceAbove25m : AISpatialCond
{
	distance = ( 25.f, -1.f );
	target = "AIActionTarget.StimSource";
}

StimTargetBelow45deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( -1.f, 45.f );
}

StimTargetAbove270deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 270.f, -1.f );
}

StimTargetAbove90degLeft : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 90.f, -1.f );
	angleDirection = -1.f;
}

StimTargetBelow270degLeft : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( -1.f, 270.f );
	angleDirection = -1.f;
}

StimTargetAbove90degRight : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 90.f, -1.f );
	angleDirection = 1.f;
}

StimTargetBelow270degRight : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( -1.f, 270.f );
	angleDirection = 1.f;
}

StimTargetBack45deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 45.f, -1.f );
}

StimTargetBack200deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 200.f, -1.f );
}

StimTargetBack260deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 260.f, -1.f );
}

StimTargetFront260deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( -1.f, 260.f );
}

StimTargetFront200deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( -1.f, 200.f );
}

StimTargetFront180deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( -1.f, 180.f );
}

StimTargetFront120deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( -1.f, 120.f );
}

StimTargetFront90deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( -1.f, 90.f );
}

StimTargetFront40deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( -1.f, 40.f );
}

StimTargetBelow15deg : AISpatialCond
{
	coneAngle = ( -1.f, 15.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetAbove20deg : AISpatialCond
{
	coneAngle = ( 20.f, -1.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetAbove45deg : AISpatialCond
{
	coneAngle = ( 45.f, -1.f );
	target = "AIActionTarget.StimTarget";
}

StimTargetLeftSide : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 90.f, 260.f );
	angleDirection = 1.f;
}

StimTargetRightSide : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 90.f, 260.f );
	angleDirection = -1.f;
}

StimTargetLeftBack : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 260.f, -1.f );
	angleDirection = -1.f;
}

StimTargetRightBack : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 260.f, -1.f );
	angleDirection = 1.f;
}

StimTargetBack40degTargetPOV : AISpatialCond
{
	useTargetPOV = true;
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 40.f, -1.f );
}

StimSourceBack45deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 45.f, -1.f );
}

StimSourceBack200deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 200.f, -1.f );
}

StimSourceBack260deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 260.f, -1.f );
}

StimSourceFront200deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( -1.f, 200.f );
}

StimSourceFront90deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( -1.f, 90.f );
}

StimSourceFront40deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( -1.f, 40.f );
}

StimSourceBelow15deg : AISpatialCond
{
	coneAngle = ( -1.f, 15.f );
	target = "AIActionTarget.StimSource";
}

StimSourceBelow30deg : AISpatialCond
{
	coneAngle = ( -1.f, 30.f );
	target = "AIActionTarget.StimSource";
}

StimSourceAbove25deg : AISpatialCond
{
	coneAngle = ( 25.f, -1.f );
	target = "AIActionTarget.StimSource";
}

StimSourceAbove45deg : AISpatialCond
{
	coneAngle = ( 45.f, -1.f );
	target = "AIActionTarget.StimSource";
}

StimSourceFrontRight90deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( -1.f, 90.f );
	angleDirection = 1.f;
	considerDirectionsOnly = true;
}

StimSourceFrontLeft90deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( -1.f, 90.f );
	angleDirection = -1.f;
	considerDirectionsOnly = true;
}

StimSourceRightBack : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 90.f, -1.f );
	considerDirectionsOnly = true;
}

StimSourceLeftBack : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 90.f, -1.f );
	considerDirectionsOnly = true;
}

StimSourceLeftSideBack160deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 160.f, -1.f );
	angleDirection = -1.f;
}

StimSourceRightSideBack160deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 160.f, -1.f );
	angleDirection = 1.f;
}

StimSourceLeftSideFront160deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( -1.f, 160.f );
	angleDirection = -1.f;
}

StimSourceRightSideFront160deg : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( -1.f, 160.f );
	angleDirection = 1.f;
}

StimSourceFrontSides : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 180.f, 260.f );
}

StimSourceBackSides : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 90.f, 180.f );
}

StimSourceLeftSide : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 90.f, 260.f );
	angleDirection = 1.f;
}

StimSourceRightSide : AISpatialCond
{
	target = "AIActionTarget.StimSource";
	coneAngle = ( 90.f, 260.f );
	angleDirection = -1.f;
}

StimTargetAbove3mBack230deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	coneAngle = ( 230.f, -1.f );
	distance = ( 3f, -1f );
}

StimTargetAbove7point5mBack180deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( 7.5f, -1f );
	coneAngle = ( 180f, -1f );
}

StimTargetAbove12point5mFront180deg : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	distance = ( 12.5f, -1f );
	coneAngle = ( -1.f, 180.f );
}

StimTargetToSpawnPositionAbove20m : AISpatialCond
{
	source = "AIActionTarget.StimTarget";
	target = "AIActionTarget.SpawnPosition";
	distance = ( 20f, -1f );
}

StimTargetBelow1point5mPrediction0point1 : AISpatialCond
{
	target = "AIActionTarget.StimTarget";
	predictionTime = 0.1f;
	distance = ( 0.f, 1.5f );
}

CustomWorldPositionBelow45deg : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	coneAngle = ( -1.f, 45.f );
}

CustomWorldPositionAbove45deg : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	coneAngle = ( 45.f, -1.f );
}

CustomWorldPositionFront30deg : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	coneAngle = ( -1.f, 30.f );
}

CustomWorldPositionBack45deg : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	coneAngle = ( 45.f, -1.f );
}

CustomWorldPosition1point8High : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	zDiff = ( 1.8f, -1.f );
}

CustomWorldPosition0point4Low : AISpatialCond
{
	target = "AIActionTarget.CustomWorldPosition";
	zDiff = ( 0.f, 0.4f );
}

PlayerAbove15m : AISpatialCond
{
	target = "AIActionTarget.Player";
	distance = ( 15f, -1f );
}

PlayerAbove5m : AISpatialCond
{
	target = "AIActionTarget.Player";
	distance = ( 5f, -1f );
}

PlayerBelow5m : AISpatialCond
{
	target = "AIActionTarget.Player";
	distance = ( -1f, 5f );
}

PlayerAbove3m : AISpatialCond
{
	target = "AIActionTarget.Player";
	distance = ( 3f, -1f );
}

PlayerBelow3m : AISpatialCond
{
	target = "AIActionTarget.Player";
	distance = ( -1f, 3f );
}

PlayerBelow10m : AISpatialCond
{
	target = "AIActionTarget.Player";
	distance = ( -1f, 10f );
}

PlayerBelow15m : AISpatialCond
{
	target = "AIActionTarget.Player";
	distance = ( -1f, 15f );
}

PlayerAbove25m : AISpatialCond
{
	target = "AIActionTarget.Player";
	distance = ( 25f, -1f );
}

PlayerAbove45m : AISpatialCond
{
	target = "AIActionTarget.Player";
	distance = ( 45f, -1f );
}

PlayerBelow30m : AISpatialCond
{
	target = "AIActionTarget.Player";
	distance = ( -1f, 30f );
}

PlayerAbove15deg : AISpatialCond
{
	coneAngle = ( 15.f, -1.f );
	target = "AIActionTarget.Player";
}

PlayerBelow15deg : AISpatialCond
{
	coneAngle = ( -1.f, 15.f );
	target = "AIActionTarget.Player";
}

ItemBelow1m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( -1.f, 1.f );
}

ItemAbove1m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( 1.f, -1.f );
}

ItemBelow2m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( -1.f, 2.f );
}

ItemAbove2m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( 2.f, -1.f );
}

ItemBelow30m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( -1.f, 30.f );
}

ItemAbove30m : AISpatialCond
{
	target = "AIActionTarget.TargetItem";
	distance = ( 30.f, -1.f );
}

NotTargetItem : TargetItem
{
	invert = true;
}

TargetItem : AITargetCond
{
	target = "AIActionTarget.TargetItem";
}

AssignedVehicleBelow15mToTarget : AISpatialCond
{
	source = "AIActionTarget.CombatTarget";
	target = "AIActionTarget.AssignedVehicle";
	distance = ( -1.f, 15.f );
}

AssignedVehicleAbove15mToTarget : AISpatialCond
{
	source = "AIActionTarget.CombatTarget";
	target = "AIActionTarget.AssignedVehicle";
	distance = ( 15.f, -1.f );
}

AssignedVehicleBelow15m : AISpatialCond
{
	target = "AIActionTarget.AssignedVehicle";
	distance = ( -1.f, 15.f );
}

AssignedVehicleAbove15m : AISpatialCond
{
	target = "AIActionTarget.AssignedVehicle";
	distance = ( 15.f, -1.f );
}

AssignedVehicleBelow10m : AISpatialCond
{
	target = "AIActionTarget.AssignedVehicle";
	distance = ( -1.f, 10.f );
}

AssignedVehicleAbove10m : AISpatialCond
{
	target = "AIActionTarget.AssignedVehicle";
	distance = ( 10.f, -1.f );
}

TargetRealPositionBelow8m : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	distance = ( -1.f, 8.f );
}

TargetRealPositionAbove8m : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	distance = ( 8.f, -1.f );
}

TargetRealPositionBelow15m : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	distance = ( -1.f, 15.f );
}

TargetRealPositionAbove15m : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	distance = ( 15.f, -1.f );
}

TargetRealPositionBelow30m : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	distance = ( -1.f, 30.f );
}

TargetRealPositionAbove30m : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	distance = ( 30.f, -1.f );
}

TargetRealPositionAbove90deg : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	coneAngle = ( 90.f, -1.f );
}

TargetRealPositionBelow90deg : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	coneAngle = ( -1.f, 90.0f );
}

TargetRealPositionAbove180deg : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	coneAngle = ( 180.f, -1.f );
}

TargetRealPositionBelow180deg : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	coneAngle = ( -1.f, 180.f );
}

TargetRealPositionBelow260deg : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	coneAngle = ( -1.f, 260.f );
}

TargetRealPositionBelow315deg : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	coneAngle = ( -1.f, 315.f );
}

TargetRealPositionLeft : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	angleDirection = -1;
}

TargetRealPositionRight : AISpatialCond
{
	target = "VehicleActions.CombatTarget";
	angleDirection = 1;
}

FriendInRangeCondition : AISpatialCond
{
	target = "AIActionTarget.FriendlyTarget";
	spatialHintMults = ( 1.f, 1.5f, 2.f );
	zDiff = ( -1.f, 3.7f );
}

NotGetOutOfWayPredictionCond : GetOutOfWayPredictionCond
{
	invert = true;
}

GetOutOfWayPredictionCond : IsFriendInTooCloseRange
{
	predictionTime = 0.1f;
}

NotIsFriendInTooCloseRange : IsFriendInTooCloseRange
{
	invert = true;
}

IsFriendInTooCloseRange : FriendInRangeCondition
{
	distance = ( -1.f, 1.5f );
}

IsFriendInCloseRange : FriendInRangeCondition
{
	distance = ( -1.f, 6.f );
}

NotIsCoverInMiddleRange : IsCoverInMiddleRange
{
	invert = true;
}

IsCoverInMiddleRange : IsFriendInMiddleRange
{
	source = "AIActionTarget.DesiredCover";
}

IsFriendInMiddleRange : FriendInRangeCondition
{
	distance = ( -1.f, 9.f );
}

NotIsFriendInMiddleRange : IsFriendInMiddleRange
{
	invert = true;
}

NotIsFriendInFarRange : FriendInRangeCondition
{
	distance = ( 12.f, -1.f );
}

IsFriendInFarRange : FriendInRangeCondition
{
	distance = ( -1.f, 12.f );
}

NotIsFriendInVeryFarRange : FriendInRangeCondition
{
	distance = ( 17.f, -1.f );
}

IsFriendInVeryFarRange : FriendInRangeCondition
{
	distance = ( -1.f, 17.f );
}

DestinationDistanceInRangeCondition : AIMovementCond
{
	spatialHintMults = ( 1.f, 1.5f, 2.f );
}

IsDistanceToDestinationInCloseRange : DestinationDistanceInRangeCondition
{
	distanceToDestination = ( -1.f, 6.f );
}

IsDistanceToDestinationInMediumRange : DestinationDistanceInRangeCondition
{
	distanceToDestination = ( -1.f, 9.f );
}

NotIsDistanceToDestinationInFarRange : IsDistanceToDestinationInFarRange
{
	invert = true;
}

IsDistanceToDestinationInFarRange : DestinationDistanceInRangeCondition
{
	distanceToDestination = ( -1.f, 12.f );
}

NotIsDistanceToDestinationInVeryFarRange : IsDistanceToDestinationInVeryFarRange
{
	invert = true;
}

IsDistanceToDestinationInVeryFarRange : DestinationDistanceInRangeCondition
{
	distanceToDestination = ( -1.f, 17.f );
}

NotInsideDangerousArea : InsideDangerousArea
{
	invert = true;
}

InsideDangerousArea : AISecurityCond
{
	areaType = "AIActionSecurityAreaType.Dangerous";
}

NotStatusEffectBerserker : StatusEffectBerserker
{
	invert = true;
}

StatusEffectBerserker : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Berserker";
}

NotStatusEffectBerserkNPCBuff : StatusEffectBerserkNPCBuff
{
	invert = true;
}

StatusEffectBerserkNPCBuff : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.BerserkNPCBuff";
}

NotStatusEffectBerserkNPCDownState : StatusEffectBerserkNPCDownState
{
	invert = true;
}

StatusEffectBerserkNPCDownState : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.BerserkNPCDownState";
}

NotStatusEffectPainInhibitors : StatusEffectPainInhibitors
{
	invert = true;
}

StatusEffectPainInhibitors : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.PainInhibitors";
}

NotStatusEffectSandevistanBuff : StatusEffectSandevistanBuff
{
	invert = true;
}

StatusEffectSandevistanBuff : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.SandevistanBuff";
}

NotStatusEffectSandevistanPlayerBuff : StatusEffectSandevistanPlayerBuff
{
	invert = true;
}

StatusEffectSandevistanPlayerBuff : AIStatusEffectCond
{
	target = "AIActionTarget.Player";
	gameplayTag = "SandevistanPlayerBuff";
}

NotTargetStatusEffectSandevistanBuff : TargetStatusEffectSandevistanBuff
{
	invert = true;
}

TargetStatusEffectSandevistanBuff : AIActionOR
{
	OR = 
	[
		{
			target = "AIActionTarget.CombatTarget";
		} : StatusEffectSandevistanBuff, 
		{
			target = "AIActionTarget.CombatTarget";
		} : StatusEffectSandevistanPlayerBuff
	];
}

NotStatusEffectSandevistanVersusSandevistanDelay : StatusEffectSandevistanVersusSandevistanDelay
{
	invert = true;
}

StatusEffectSandevistanVersusSandevistanDelay : AIStatusEffectCond
{
	gameplayTag = "SandevistanVersusSandevistanDelay";
}

StatusEffectSandevistanVersusSandevistanDelayHelper : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.SandevistanVersusSandevistanDelayHelper";
}

NotStatusEffectTagWounded : StatusEffectTagWounded
{
	invert = true;
}

StatusEffectTagWounded : AIStatusEffectCond
{
	gameplayTag = "Wounded";
}

NotStatusEffectTagCrippled : StatusEffectTagCrippled
{
	invert = true;
}

StatusEffectTagCrippled : AIStatusEffectCond
{
	gameplayTag = "Crippled";
}

NotStatusEffectTagCrippledLeg : StatusEffectTagCrippledLeg
{
	invert = true;
}

StatusEffectTagCrippledLeg : AIStatusEffectCond
{
	gameplayTag = "CrippledLeg";
}

NotStatusEffectTagCrippledArm : StatusEffectTagCrippledArm
{
	invert = true;
}

StatusEffectTagCrippledArm : AIStatusEffectCond
{
	gameplayTag = "CrippledArm";
}

NotStatusEffectCrippledLegLeft : StatusEffectCrippledLegLeft
{
	invert = true;
}

StatusEffectCrippledLegLeft : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CrippledLegLeft";
}

NotStatusEffectCrippledLegRight : StatusEffectCrippledLegRight
{
	invert = true;
}

StatusEffectCrippledLegRight : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CrippledLegRight";
}

NotStatusEffectCrippledArmLeft : StatusEffectCrippledArmLeft
{
	invert = true;
}

StatusEffectCrippledArmLeft : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CrippledArmLeft";
}

NotStatusEffectCrippledHandLeft : StatusEffectCrippledHandLeft
{
	invert = true;
}

StatusEffectCrippledHandLeft : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CrippledHandLeft";
}

NotStatusEffectCrippledArmRight : StatusEffectCrippledArmRight
{
	invert = true;
}

StatusEffectCrippledArmRight : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CrippledArmRight";
}

NotStatusEffectCrippledHandRight : StatusEffectCrippledHandRight
{
	invert = true;
}

StatusEffectCrippledHandRight : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CrippledHandRight";
}

NotStatusEffectTagDismembered : StatusEffectTagDismembered
{
	invert = true;
}

StatusEffectTagDismembered : AIStatusEffectCond
{
	gameplayTag = "Dismembered";
}

NotStatusEffectTagDismemberedLeg : StatusEffectTagDismemberedLeg
{
	invert = true;
}

StatusEffectTagDismemberedLeg : AIStatusEffectCond
{
	gameplayTag = "DismemberedLeg";
}

NotStatusEffectTagDismemberedArm : StatusEffectTagDismemberedArm
{
	invert = true;
}

StatusEffectTagDismemberedArm : AIStatusEffectCond
{
	gameplayTag = "DismemberedArm";
}

NotStatusEffectDismemberedLegLeft : StatusEffectDismemberedLegLeft
{
	invert = true;
}

StatusEffectDismemberedLegLeft : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.DismemberedLegLeft";
}

NotStatusEffectDismemberedLegRight : StatusEffectDismemberedLegRight
{
	invert = true;
}

StatusEffectDismemberedLegRight : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.DismemberedLegRight";
}

NotStatusEffectDismemberedArmLeft : StatusEffectDismemberedArmLeft
{
	invert = true;
}

StatusEffectDismemberedArmLeft : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.DismemberedArmLeft";
}

NotStatusEffectDismemberedHandLeft : StatusEffectDismemberedHandLeft
{
	invert = true;
}

StatusEffectDismemberedHandLeft : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.DismemberedHandLeft";
}

NotStatusEffectDismemberedArmRight : StatusEffectDismemberedArmRight
{
	invert = true;
}

StatusEffectDismemberedArmRight : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.DismemberedArmRight";
}

NotStatusEffectDismemberedHandRight : StatusEffectDismemberedHandRight
{
	invert = true;
}

StatusEffectDismemberedHandRight : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.DismemberedHandRight";
}

NotStatusEffectTagLeftArm : StatusEffectTagLeftArm
{
	invert = true;
}

StatusEffectTagLeftArm : AIStatusEffectCond
{
	gameplayTag = "LeftArm";
}

NotStatusEffectTagRightArm : StatusEffectTagRightArm
{
	invert = true;
}

StatusEffectTagRightArm : AIStatusEffectCond
{
	gameplayTag = "RightArm";
}

NotStatusEffectCyberwareMalfunction : StatusEffectCyberwareMalfunction
{
	invert = true;
}

StatusEffectCyberwareMalfunction : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CyberwareMalfunction";
}

NotStatusEffectTypeWeaponMalfunction : StatusEffectTypeWeaponMalfunction
{
	invert = true;
}

StatusEffectTypeWeaponMalfunction : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.Jam";
}

NotStatusEffectWeaponMalfunction : StatusEffectWeaponMalfunction
{
	invert = true;
}

StatusEffectWeaponMalfunction : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.WeaponMalfunction";
}

NotStatusEffectWeaponMalfunctionLvl2 : StatusEffectWeaponMalfunctionLvl2
{
	invert = true;
}

StatusEffectWeaponMalfunctionLvl2 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.WeaponMalfunctionLvl2";
}

NotStatusEffectWeaponMalfunctionLvl3 : StatusEffectWeaponMalfunctionLvl3
{
	invert = true;
}

StatusEffectWeaponMalfunctionLvl3 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.WeaponMalfunctionLvl3";
}

NotStatusEffectWeaponMalfunctionLvl4 : StatusEffectWeaponMalfunctionLvl4
{
	invert = true;
}

StatusEffectWeaponMalfunctionLvl4 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.WeaponMalfunctionLvl4";
}

NotStatusEffectWeaponMalfunctionRepeat : StatusEffectWeaponMalfunctionRepeat
{
	invert = true;
}

StatusEffectWeaponMalfunctionRepeat : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.WeaponMalfunctionRepeat";
}

NotStatusEffectExhausted : StatusEffectExhausted
{
	invert = true;
}

StatusEffectExhausted : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Exhausted";
}

NotStatusEffectDefeated : StatusEffectDefeated
{
	invert = true;
}

StatusEffectDefeated : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Defeated";
}

NotStatusEffectUnconscious : StatusEffectUnconscious
{
	invert = true;
}

StatusEffectUnconscious : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Unconscious";
}

NotStatusEffectDoNotUseVehicle : StatusEffectDoNotUseVehicle
{
	invert = true;
}

StatusEffectDoNotUseVehicle : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.DoNotUseVehicle";
}

NotStatusEffectDoNotBlockShootingOnFriendlyFire : StatusEffectDoNotBlockShootingOnFriendlyFire
{
	invert = true;
}

StatusEffectDoNotBlockShootingOnFriendlyFire : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.DoNotBlockShootingOnFriendlyFire";
}

NotStatusEffectFollowerGameplayRestrictionNoCombat : StatusEffectFollowerGameplayRestrictionNoCombat
{
	invert = true;
}

StatusEffectFollowerGameplayRestrictionNoCombat : AIStatusEffectCond
{
	target = "AIActionTarget.FriendlyTarget";
	statusEffect = "GameplayRestriction.NoCombat";
}

NotStatusEffectStimTargetGameplayRestrictionNoCombat : StatusEffectStimTargetGameplayRestrictionNoCombat
{
	invert = true;
}

StatusEffectStimTargetGameplayRestrictionNoCombat : AIStatusEffectCond
{
	target = "AIActionTarget.StimTarget";
	statusEffect = "GameplayRestriction.NoCombat";
}

NotStatusEffectPlayerGameplayRestrictionNoCombat : StatusEffectPlayerGameplayRestrictionNoCombat
{
	invert = true;
}

StatusEffectPlayerGameplayRestrictionNoCombat : AIStatusEffectCond
{
	target = "AIActionTarget.Player";
	statusEffect = "GameplayRestriction.NoCombat";
}

NotDontShootCombatTarget : DontShootCombatTarget
{
	invert = true;
}

DontShootCombatTarget : AIActionOR
{
	OR = 
	[
		{
			target = "AIActionTarget.CombatTarget";
		} : StatusEffectDontShootAtMe, 
		{
			AND = 
			[
				"Condition.TargetIsPlayer", {
					target = "AIActionTarget.CombatTarget";
					gameplayTag = "NoCombat";
				} : AIStatusEffectCond
			];
		} : AIActionAND
	];
}

StatusEffectDontShootAtMe : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.DontShootAtMe";
}

NotStatusEffectTypeBurning : StatusEffectTypeBurning
{
	invert = true;
}

StatusEffectTypeBurning : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.Burning";
}

NotStatusEffectBurning : StatusEffectBurning
{
	invert = true;
}

StatusEffectBurning : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Burning";
}

NotStatusEffectMediumBurning : StatusEffectMediumBurning
{
	invert = true;
}

StatusEffectMediumBurning : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.MediumBurning";
}

NotStatusEffectStackableMediumBurning : StatusEffectStackableMediumBurning
{
	invert = true;
}

StatusEffectStackableMediumBurning : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.EpicBurnGrenade";
}

NotTargetStatusEffectTypeBurning : TargetStatusEffectTypeBurning
{
	invert = true;
}

TargetStatusEffectTypeBurning : AIStatusEffectCond
{
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
	statusEffectType = "BaseStatusEffectTypes.Burning";
}

NotStatusEffectOverheat : StatusEffectOverheat
{
	invert = true;
}

StatusEffectOverheat : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Overheat";
}

NotStatusEffectOverheatLevel1 : StatusEffectOverheatLevel1
{
	invert = true;
}

StatusEffectOverheatLevel1 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.OverheatLevel1";
}

NotStatusEffectOverheatLevel2 : StatusEffectOverheatLevel2
{
	invert = true;
}

StatusEffectOverheatLevel2 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.OverheatLevel2";
}

NotStatusEffectOverheatLevel3 : StatusEffectOverheatLevel3
{
	invert = true;
}

StatusEffectOverheatLevel3 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.OverheatLevel3";
}

NotStatusEffectOverheatLevel4 : StatusEffectOverheatLevel4
{
	invert = true;
}

StatusEffectOverheatLevel4 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.OverheatLevel4";
}

NotStatusEffectTypeStun : StatusEffectTypeStun
{
	invert = true;
}

StatusEffectTypeStun : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.Stunned";
}

NotStatusEffectStun : StatusEffectStun
{
	invert = true;
}

StatusEffectStun : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Stun";
}

NotStatusEffectTypeBlind : StatusEffectTypeBlind
{
	invert = true;
}

StatusEffectTypeBlind : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.Blind";
}

NotTargetStatusEffectTypeBlind : TargetStatusEffectTypeBlind
{
	invert = true;
}

TargetStatusEffectTypeBlind : AIStatusEffectCond
{
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
	statusEffectType = "BaseStatusEffectTypes.Blind";
}

NotStatusEffectBlind : StatusEffectBlind
{
	invert = true;
}

StatusEffectBlind : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Blind";
}

NotStatusEffectMajorBlind : StatusEffectMajorBlind
{
	invert = true;
}

StatusEffectMajorBlind : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.MajorBlind";
}

NotStatusEffectMinorBlind : StatusEffectMinorBlind
{
	invert = true;
}

StatusEffectMinorBlind : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.MinorBlind";
}

NotStatusEffectTagQuickHackBlind : StatusEffectTagQuickHackBlind
{
	invert = true;
}

StatusEffectTagQuickHackBlind : AIStatusEffectCond
{
	gameplayTag = "QuickHackBlind";
}

NotStatusEffectQuickHackBlind : StatusEffectQuickHackBlind
{
	invert = true;
}

StatusEffectQuickHackBlind : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.QuickHackBlind";
}

NotStatusEffectQuickHackBlindLevel2 : StatusEffectQuickHackBlindLevel2
{
	invert = true;
}

StatusEffectQuickHackBlindLevel2 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.QuickHackBlindLevel2";
}

NotStatusEffectQuickHackBlindLevel3 : StatusEffectQuickHackBlindLevel3
{
	invert = true;
}

StatusEffectQuickHackBlindLevel3 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.QuickHackBlindLevel3";
}

NotStatusEffectQuickHackBlindLevel4 : StatusEffectQuickHackBlindLevel4
{
	invert = true;
}

StatusEffectQuickHackBlindLevel4 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.QuickHackBlindLevel4";
}

NotStatusEffectMemoryWipeLevel4 : StatusEffectMemoryWipeLevel4
{
	invert = true;
}

StatusEffectMemoryWipeLevel4 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.MemoryWipeLevel4";
}

NotStatusEffectMemoryWipeLevel3 : StatusEffectMemoryWipeLevel3
{
	invert = true;
}

StatusEffectMemoryWipeLevel3 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.MemoryWipeLevel3";
}

NotStatusEffectMemoryWipeLevel2 : StatusEffectMemoryWipeLevel2
{
	invert = true;
}

StatusEffectMemoryWipeLevel2 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.MemoryWipeLevel2";
}

NotStatusEffectBossMemoryWipe : StatusEffectMemoryWipeLevel2
{
	invert = true;
}

StatusEffectBossMemoryWipe : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.BossMemoryWipe";
}

NotStatusEffectReducedVisibility : StatusEffectReducedVisibility
{
	invert = true;
}

StatusEffectReducedVisibility : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.ReducedVisibility";
}

NotStatusEffectGreaterReducedVisibility : StatusEffectGreaterReducedVisibility
{
	invert = true;
}

StatusEffectGreaterReducedVisibility : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.GreaterReducedVisibility";
}

NotStatusEffectHearingImpaired : StatusEffectHearingImpaired
{
	invert = true;
}

StatusEffectHearingImpaired : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.HearingImpaired";
}

NotStatusEffectSeverelyHearingImpaired : StatusEffectSeverelyHearingImpaired
{
	invert = true;
}

StatusEffectSeverelyHearingImpaired : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.SeverelyHearingImpaired";
}

NotStatusEffectTypePoisoned : StatusEffectTypePoisoned
{
	invert = true;
}

StatusEffectTypePoisoned : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.Poisoned";
}

NotStatusEffectPoisoned : StatusEffectPoisoned
{
	invert = true;
}

StatusEffectPoisoned : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Poisoned";
}

NotStatusEffectHeavyPoision : StatusEffectHeavyPoision
{
	invert = true;
}

StatusEffectHeavyPoision : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.HeavyPoision";
}

NotStatusEffectDrugged : StatusEffectDrugged
{
	invert = true;
}

StatusEffectDrugged : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Drugged";
}

NotStatusEffectDruggedSevere : StatusEffectDruggedSevere
{
	invert = true;
}

StatusEffectDruggedSevere : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.DruggedSevere";
}

NotStatusEffectTypeBleeding : StatusEffectTypeBleeding
{
	invert = true;
}

StatusEffectTypeBleeding : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.Bleeding";
}

NotStatusEffectBleeding : StatusEffectBleeding
{
	invert = true;
}

StatusEffectBleeding : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Bleeding";
}

NotStatusEffectTypeEMP : StatusEffectTypeEMP
{
	invert = true;
}

StatusEffectTypeEMP : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.EMP";
}

NotStatusEffectEMP : StatusEffectEMP
{
	invert = true;
}

StatusEffectEMP : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.EMP";
}

NotStatusEffectEmpLowDamage : StatusEffectEmpLowDamage
{
	invert = true;
}

StatusEffectEmpLowDamage : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.EmpLowDamage";
}

NotStatusEffectEmpHighDamage : StatusEffectEmpHighDamage
{
	invert = true;
}

StatusEffectEmpHighDamage : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.EmpHighDamage";
}

NotStatusEffectEmpJamWeaponChance : StatusEffectEmpJamWeaponChance
{
	invert = true;
}

StatusEffectEmpJamWeaponChance : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.EmpJamWeaponChance";
}

NotStatusEffectEmpJamWeaponAccuracyDebuff : StatusEffectEmpJamWeaponAccuracyDebuff
{
	invert = true;
}

StatusEffectEmpJamWeaponAccuracyDebuff : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.EmpJamWeaponAccuracyDebuff";
}

NotStatusEffectForceShoot : StatusEffectForceShoot
{
	invert = true;
}

StatusEffectForceShoot : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.ForceShoot";
}

NotStatusEffectTypeCommsNoise : StatusEffectTypeCommsNoise
{
	invert = true;
}

StatusEffectTypeCommsNoise : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.CommsNoise";
}

NotStatusEffectCommsNoise : StatusEffectCommsNoise
{
	invert = true;
}

StatusEffectCommsNoise : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CommsNoise";
}

NotStatusEffectCommsNoiseLevel2 : StatusEffectCommsNoiseLevel2
{
	invert = true;
}

StatusEffectCommsNoiseLevel2 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CommsNoiseLevel2";
}

NotStatusEffectCommsNoiseLevel3 : AIStatusEffectCond
{
	invert = true;
	statusEffect = "BaseStatusEffect.CommsNoiseLevel3";
}

StatusEffectCommsNoiseLevel3 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CommsNoiseLevel3";
}

NotStatusEffectCommsNoiseLevel4 : StatusEffectCommsNoiseLevel4
{
	invert = true;
}

StatusEffectCommsNoiseLevel4 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CommsNoiseLevel4";
}

NotStatusEffectCommsCallIn : StatusEffectCommsCallIn
{
	invert = true;
}

StatusEffectCommsCallIn : AIStatusEffectCond
{
	gameplayTag = "CommsCallIn";
}

NotStatusEffectCombatCommsCallIn : StatusEffectCombatCommsCallIn
{
	invert = true;
}

StatusEffectCombatCommsCallIn : AIStatusEffectCond
{
	gameplayTag = "CombatCommsCallIn";
}

NotStatusEffectCommsCallOutOnCommsNoise : StatusEffectCommsCallOutOnCommsNoise
{
	invert = true;
}

StatusEffectCommsCallOutOnCommsNoise : AIStatusEffectCond
{
	gameplayTag = "CommsCallOutOnCommsNoise";
}

StatusEffectTagCommsNoiseIgnore : AIStatusEffectCond
{
	gameplayTag = "CommsNoiseIgnore";
}

NotStatusEffectWhistle : StatusEffectWhistle
{
	invert = true;
}

StatusEffectWhistle : AIStatusEffectCond
{
	gameplayTag = "Whistle";
}

NotStatusEffectCombatWhistle : StatusEffectCombatWhistle
{
	invert = true;
}

StatusEffectCombatWhistle : AIStatusEffectCond
{
	gameplayTag = "CombatWhistle";
}

NotStatusEffectWhistleTurnAway : StatusEffectWhistleTurnAway
{
	invert = true;
}

StatusEffectWhistleTurnAway : AIStatusEffectCond
{
	gameplayTag = "WhistleTurnAway";
}

NotStatusEffectAlertedWhistle : StatusEffectAlertedWhistle
{
	invert = true;
}

StatusEffectAlertedWhistle : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.WhistleLvl0";
}

NotStatusEffectTypeLocomotionMalfunction : StatusEffectTypeLocomotionMalfunction
{
	invert = true;
}

StatusEffectTypeLocomotionMalfunction : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.QuickHackStaggerLocomotion";
}

NotStatusEffectTypeFreezeLocomotionMalfunction : StatusEffectTypeFreezeLocomotionMalfunction
{
	invert = true;
}

StatusEffectTypeFreezeLocomotionMalfunction : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.QuickHackFreezeLocomotion";
}

NotStatusEffectLocomotionMalfunction : StatusEffectLocomotionMalfunction
{
	invert = true;
}

StatusEffectLocomotionMalfunction : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.LocomotionMalfunction";
}

NotStatusEffectLocomotionMalfunctionLevel2 : StatusEffectLocomotionMalfunctionLevel2
{
	invert = true;
}

StatusEffectLocomotionMalfunctionLevel2 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.LocomotionMalfunctionLevel2";
}

NotStatusEffectLocomotionMalfunctionLevel3 : StatusEffectLocomotionMalfunctionLevel3
{
	invert = true;
}

StatusEffectLocomotionMalfunctionLevel3 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.LocomotionMalfunctionLevel3";
}

NotStatusEffectLocomotionMalfunctionLevel4 : StatusEffectLocomotionMalfunctionLevel4
{
	invert = true;
}

StatusEffectLocomotionMalfunctionLevel4 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.LocomotionMalfunctionLevel4";
}

NotStatusEffectOverload : StatusEffectOverload
{
	invert = true;
}

StatusEffectOverload : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Overload";
}

NotStatusEffectTypeEmp : StatusEffectTypeEmp
{
	invert = true;
}

StatusEffectTypeEmp : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.EMP";
}

NotTargetStatusEffectTypeEMP : TargetStatusEffectTypeEMP
{
	invert = true;
}

TargetStatusEffectTypeEMP : AIStatusEffectCond
{
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
	statusEffectType = "BaseStatusEffectTypes.EMP";
}

NotStatusEffectMadness : StatusEffectMadness
{
	invert = true;
}

StatusEffectMadness : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Madness";
}

StatusEffectMadnessCombatTarget : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Madness";
	target = "AIActionTarget.CombatTarget";
}

NotStatusEffectTypeMadness : StatusEffectTypeMadness
{
	invert = true;
}

StatusEffectTypeMadness : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.Madness";
}

StatusEffectSetFriendlyCombatTarget : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.SetFriendly";
	target = "AIActionTarget.CombatTarget";
}

NotStatusEffectSetFriendly : StatusEffectSetFriendly
{
	invert = true;
}

StatusEffectSetFriendly : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.SetFriendly";
}

NotStatusEffectAndroidTurnOn : StatusEffectAndroidTurnOn
{
	invert = true;
}

StatusEffectAndroidTurnOn : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.AndroidTurnOn";
}

NotStatusEffectNPCForceEquipPrimaryWeapon : StatusEffectNPCForceEquipPrimaryWeapon
{
	invert = true;
}

StatusEffectNPCForceEquipPrimaryWeapon : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.NPCForceEquipPrimaryWeapon";
}

NotStatusEffectNPCForceEquipSecondaryWeapon : StatusEffectNPCForceEquipSecondaryWeapon
{
	invert = true;
}

StatusEffectNPCForceEquipSecondaryWeapon : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.NPCForceEquipSecondaryWeapon";
}

NotStatusEffectAndroidTurnOff : StatusEffectAndroidTurnOff
{
	invert = true;
}

StatusEffectAndroidTurnOff : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.AndroidTurnOff";
}

NotStatusEffectSystemCollapse : StatusEffectSystemCollapse
{
	invert = true;
}

StatusEffectSystemCollapse : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.SystemCollapse";
}

NotStatusEffectBossSystemCollapse : StatusEffectSystemCollapse
{
	invert = true;
}

StatusEffectBossSystemCollapse : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.BossSystemCollapse";
}

NotStatusEffectBossSystemCollapseHackReactionImmunity : StatusEffectBossSystemCollapseHackReactionImmunity
{
	invert = true;
}

StatusEffectBossSystemCollapseHackReactionImmunity : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.BossSystemCollapseHackReactionImmunity";
}

NotStatusEffectTypeBrainMelt : StatusEffectTypeBrainMelt
{
	invert = true;
}

StatusEffectTypeBrainMelt : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.BrainMelt";
}

NotStatusEffectBrainMelt : StatusEffectBrainMelt
{
	invert = true;
}

StatusEffectBrainMelt : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.BaseBrainMelt";
}

NotStatusEffectSuicideWithWeapon : StatusEffectSuicideWithWeapon
{
	invert = true;
}

StatusEffectSuicideWithWeapon : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.SuicideWithWeapon";
}

NotStatusEffectSuicideMotion : StatusEffectSuicideMotion
{
	invert = true;
}

StatusEffectSuicideMotion : AIStatusEffectCond
{
	statusEffect = "MinigameAction.SuicideMotion";
}

NotBlindedBySmokeGrenade : BlindedBySmokeGrenade
{
	invert = true;
}

BlindedBySmokeGrenade : AIStatusEffectCond
{
	statusEffect = "Oda.BlindedBySmokeGrenade";
}

NotOdaLeapBlocker : OdaLeapBlocker
{
	invert = true;
}

OdaLeapBlocker : AIStatusEffectCond
{
	statusEffect = "Oda.OdaLeapBlocker";
}

NotOdaEmergency : OdaEmergency
{
	invert = true;
}

OdaEmergency : AIStatusEffectCond
{
	statusEffect = "Oda.Emergency";
}

NotOdaNoDodge : OdaNoDodge
{
	invert = true;
}

OdaNoDodge : AIStatusEffectCond
{
	statusEffect = "Oda.OdaNoDodge";
}

NotOdaCamo : OdaCamo
{
	invert = true;
}

OdaCamo : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CloakedOda";
}

NotSasquatchDodge : SasquatchDodge
{
	invert = true;
}

SasquatchDodge : AIStatusEffectCond
{
	statusEffect = "Sasquatch.Dodge";
}

NotStatusEffectSasquatchBurningGrenade : StatusEffectSasquatchBurningGrenade
{
	invert = true;
}

StatusEffectSasquatchBurningGrenade : AIStatusEffectCond
{
	statusEffect = "Sasquatch.BurningGrenade";
}

NotStatusEffectSasquatchSuicideStagger : StatusEffectSasquatchSuicideStagger
{
	invert = true;
}

StatusEffectSasquatchSuicideStagger : AIStatusEffectCond
{
	statusEffect = "Sasquatch.ForceStaggerSuicide";
}

NotOdaHealing : OdaHealing
{
	invert = true;
}

OdaHealing : AIStatusEffectCond
{
	statusEffect = "Oda.Healing";
}

NotWagnerHealing : WagnerHealing
{
	invert = true;
}

WagnerHealing : AIStatusEffectCond
{
	statusEffect = "Oda.WagnerHealingSE";
}

NotOdaHurt : OdaHurt
{
	invert = true;
}

OdaHurt : AIStatusEffectCond
{
	statusEffect = "Oda.Hurt";
}

NotInvulnerable : Invulnerable
{
	invert = true;
}

Invulnerable : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Invulnerable";
}

NotOdaInvulnerable : OdaInvulnerable
{
	invert = true;
}

OdaInvulnerable : AIStatusEffectCond
{
	statusEffect = "Oda.Invulnerable";
}

NotOdaRevealed : OdaRevealed
{
	invert = true;
}

OdaRevealed : AIStatusEffectCond
{
	statusEffect = "Oda.Revealed";
}

NotCloakedOda : CloakedOda
{
	invert = true;
}

CloakedOda : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CloakedOda";
}

NotStatusEffectOdaLeapBlocker : StatusEffectOdaLeapBlocker
{
	invert = true;
}

StatusEffectOdaLeapBlocker : AIStatusEffectCond
{
	statusEffect = "Oda.OdaLeapBlocker";
}

NotStatusEffectStealthMode : StatusEffectStealthMode
{
	invert = true;
}

StatusEffectStealthMode : AIStatusEffectCond
{
	statusEffect = "Oda.StealthMode";
}

NotAdamSmashed : AdamSmashed
{
	invert = true;
}

AdamSmashed : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.Smashed";
}

NotAdamInCEOFloor : AdamInCEOFloor
{
	invert = true;
}

AdamInCEOFloor : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.IsInCEOFloor";
}

NotAdamSmasherDestroyedPlate : AdamSmasherDestroyedPlate
{
	invert = true;
}

AdamSmasherDestroyedPlate : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.Destroyed_Plate";
}

NotAdamSmasherCounterState : AdamSmasherCounterState
{
	invert = true;
}

AdamSmasherCounterState : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.CounterState";
}

NotAdamSmasherTakedownOverload : AdamSmasherTakedownOverload
{
	invert = true;
}

AdamSmasherTakedownOverload : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.AdamSmasherTakedownOverload";
}

NotAdamSmasherTakedownOverloadToBroken : AdamSmasherTakedownOverloadToBroken
{
	invert = true;
}

AdamSmasherTakedownOverloadToBroken : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.AdamSmasherTakedownOverloadToBroken";
}

NotAdamPhase1 : AdamPhase1
{
	invert = true;
}

AdamPhase1 : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.Phase1";
}

NotAdamPhase2 : AdamPhase2
{
	invert = true;
}

AdamPhase2 : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.Phase2";
}

NotAdamPhase3 : AdamPhase3
{
	invert = true;
}

AdamPhase3 : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.Phase3";
}

AdamWounded : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.Wounded";
}

AdamEmergency : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.Emergency";
}

NotAdamEmergency : AdamEmergency
{
	invert = true;
}

AdamInvulnerable : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.Invulnerable";
}

NotSmasherAnimationActivator : SmasherAnimationActivator
{
	invert = true;
}

SmasherAnimationActivator : AIStatusEffectCond
{
	statusEffect = "AdamSmasher.SmasherAnimationActivator";
}

NotCloaked : Cloaked
{
	invert = true;
}

Cloaked : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Cloaked";
}

MaxtacCloaked : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Cloaked";
}

PlayerBeingHacked : AIStatusEffectCond
{
	target = "AIActionTarget.Player";
	statusEffect = "AIQuickHackStatusEffect.BeingHacked";
}

NotPlayerBeingHacked : PlayerBeingHacked
{
	invert = true;
}

NotChimeraPhase1 : ChimeraPhase1
{
	invert = true;
}

ChimeraPhase1 : AIStatusEffectCond
{
	statusEffect = "Chimera.Phase1";
}

NotChimeraPhase2 : ChimeraPhase2
{
	invert = true;
}

ChimeraPhase2 : AIStatusEffectCond
{
	statusEffect = "Chimera.Phase2";
}

NotChimeraPhase3 : ChimeraPhase3
{
	invert = true;
}

ChimeraPhase3 : AIStatusEffectCond
{
	statusEffect = "Chimera.Phase3";
}

NotCombatTargetChimeraPhase1 : CombatTargetChimeraPhase1
{
	invert = true;
}

CombatTargetChimeraPhase1 : AIStatusEffectCond
{
	statusEffect = "Chimera.Phase1";
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
}

NotCombatTargetChimeraPhase2 : CombatTargetChimeraPhase2
{
	invert = true;
}

CombatTargetChimeraPhase2 : AIStatusEffectCond
{
	statusEffect = "Chimera.Phase2";
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
}

NotCombatTargetChimeraPhase3 : CombatTargetChimeraPhase3
{
	invert = true;
}

CombatTargetChimeraPhase3 : AIStatusEffectCond
{
	statusEffect = "Chimera.Phase3";
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
}

NotChimeraGasCloudBottom : ChimeraGasCloudBottom
{
	invert = true;
}

ChimeraGasCloudBottom : AIStatusEffectCond
{
	statusEffect = "Chimera.GasCloudBottom";
}

NotChimeraGasCloudTop : ChimeraGasCloudTop
{
	invert = true;
}

ChimeraGasCloudTop : AIStatusEffectCond
{
	statusEffect = "Chimera.GasCloudTop";
}

NotCombatTargetChimeraGasCloudBottom : CombatTargetChimeraGasCloudBottom
{
	invert = true;
}

CombatTargetChimeraGasCloudBottom : AIStatusEffectCond
{
	statusEffect = "Chimera.GasCloudBottom";
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
}

NotCombatTargetChimeraGasCloudTop : CombatTargetChimeraGasCloudTop
{
	invert = true;
}

CombatTargetChimeraGasCloudTop : AIStatusEffectCond
{
	statusEffect = "Chimera.GasCloudTop";
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
}

NotChimeraUnlockGasCloud : ChimeraUnlockGasCloud
{
	invert = true;
}

ChimeraUnlockGasCloud : AIStatusEffectCond
{
	statusEffect = "Chimera.UnlockGasCloud";
}

NotChimeraRepairing : ChimeraRepairing
{
	invert = true;
}

ChimeraRepairing : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraRepairing";
}

NotChimeraRepairingCombatTarget : ChimeraRepairingCombatTarget
{
	invert = true;
}

ChimeraRepairingCombatTarget : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraRepairing";
	target = "AIActionTarget.CombatTarget";
}

NotChimeraSelfDestructCountdown : ChimeraSelfDestructCountdown
{
	invert = true;
}

ChimeraSelfDestructCountdown : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraSelfDestructCountdown";
}

NotChimeraVentsOn : ChimeraVentsOn
{
	invert = true;
}

ChimeraVentsOn : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraVentsOn";
}

NotChimeraBlackWallVFXStatusEffect : ChimeraBlackWallVFXStatusEffect
{
	invert = true;
}

ChimeraBlackWallVFXStatusEffect : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraBlackWallVFXStatusEffect";
}

NotChimeraArenaModeStatusEffect : ChimeraArenaModeStatusEffect
{
	invert = true;
}

ChimeraArenaModeStatusEffect : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraArenaMode";
}

NotChimeraFocusMyers : ChimeraFocusMyers
{
	invert = true;
}

ChimeraFocusMyers : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraFocusMyers";
}

NotChimeraWaitForMyers : ChimeraWaitForMyers
{
	invert = true;
}

ChimeraWaitForMyers : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraWaitForMyers";
}

NotChimeraSignalMyersToRun : ChimeraSignalMyersToRun
{
	invert = true;
}

ChimeraSignalMyersToRun : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraSignalMyersToRun";
}

NotChimeraSignalMyersToGrenade : ChimeraSignalMyersToGrenade
{
	invert = true;
}

ChimeraSignalMyersToGrenade : AIStatusEffectCond
{
	statusEffect = "Chimera.ChimeraSignalMyersToGrenade";
}

StatusEffectCerberusGrabAttackEffect01 : AIStatusEffectCond
{
	[ EP1 ]
	statusEffect = "BaseStatusEffect.CerberusGrabAttackEffect01";
}

StatusEffectCerberusScanningVFXOn : AIStatusEffectCond
{
	[ EP1 ]
	statusEffect = "BaseStatusEffect.CerberusScanningVFXOn";
}

StatusEffectCerberusScanningVFXOff : AIStatusEffectCond
{
	[ EP1 ]
	statusEffect = "BaseStatusEffect.CerberusScanningVFXOff";
}

NotStatusEffectCerberusSkipPreAlerted : StatusEffectCerberusSkipPreAlerted
{
	invert = true;
}

StatusEffectCerberusSkipPreAlerted : AIStatusEffectCond
{
	[ EP1 ]
	statusEffect = "BaseStatusEffect.CerberusSkipPreAlerted";
}

NotStatusEffectCerberusInPreAlerted : StatusEffectCerberusInPreAlerted
{
	invert = true;
}

StatusEffectCerberusInPreAlerted : AIStatusEffectCond
{
	[ EP1 ]
	statusEffect = "BaseStatusEffect.CerberusInPreAlerted";
}

NotBossNoInterrupt : BossNoInterrupt
{
	invert = true;
}

BossNoInterrupt : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.BossNoInterrupt";
}

NotStatusEffectTargetNetwatcherGeneral : StatusEffectTargetNetwatcherGeneral
{
	invert = true;
}

StatusEffectTargetNetwatcherGeneral : AIStatusEffectCond
{
	target = "AIActionTarget.CombatTarget";
	statusEffect = "BaseStatusEffect.NetwatcherGeneral";
}

NotStatusEffectKurtKnife : StatusEffectKurtKnife
{
	invert = true;
}

StatusEffectKurtKnife : AIStatusEffectCond
{
	target = "AIActionTarget.CombatTarget";
	statusEffect = "BaseStatusEffect.KurtMeleeTakedownCooldownSE";
}

NotStatusEffectTargetKnockdown : StatusEffectTargetKnockdown
{
	invert = true;
}

StatusEffectTargetKnockdown : AIStatusEffectCond
{
	target = "AIActionTarget.CombatTarget";
	statusEffect = "BaseStatusEffect.Knockdown";
}

NotStatusEffectKnockdown : StatusEffectKnockdown
{
	invert = true;
}

StatusEffectKnockdown : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.Knockdown";
}

NotStatusEffectAnyKnockdown : StatusEffectAnyKnockdown
{
	invert = true;
}

StatusEffectAnyKnockdown : AIActionOR
{
	OR = 
	[
		"Condition.StatusEffectAnyNormalKnockdown", "Condition.StatusEffectAnyVehicleKnockdown"
	];
}

NotStatusEffectAnyNormalKnockdown : StatusEffectAnyNormalKnockdown
{
	invert = true;
}

StatusEffectAnyNormalKnockdown : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.Knockdown";
}

NotStatusEffectAnyVehicleKnockdown : StatusEffectAnyVehicleKnockdown
{
	invert = true;
}

StatusEffectAnyVehicleKnockdown : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.VehicleKnockdown";
}

NotStatusEffectKnockdownInfinite : StatusEffectKnockdownInfinite
{
	invert = true;
}

StatusEffectKnockdownInfinite : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.KnockdownInfinite";
}

NotStatusEffectOpticalCamo : StatusEffectOpticalCamo
{
	invert = true;
}

StatusEffectOpticalCamo : AIActionOR
{
	OR = 
	[
		{
			statusEffect = "BaseStatusEffect.Cloaked";
		} : AIStatusEffectCond, 
		{
			gameplayTag = "Cloak";
		} : AIStatusEffectCond
	];
}

NotTargetStatusEffectOpticalCamo : StatusEffectOpticalCamo
{
	invert = true;
}

TargetStatusEffectOpticalCamo : AIActionOR
{
	OR = 
	[
		{
			target = "AIActionTarget.CombatTarget";
			statusEffect = "BaseStatusEffect.Cloaked";
		} : AIStatusEffectCond, 
		{
			target = "AIActionTarget.CombatTarget";
			gameplayTag = "Cloak";
		} : AIStatusEffectCond
	];
}

NotStatusEffectHackingInterrupted : StatusEffectHackingInterrupted
{
	invert = true;
}

StatusEffectHackingInterrupted : AIStatusEffectCond
{
	statusEffect = "AIQuickHackStatusEffect.HackingInterrupted";
}

NotStatusEffectHacking : StatusEffectHacking
{
	invert = true;
}

StatusEffectHacking : AIStatusEffectCond
{
	statusEffect = "AIQuickHackStatusEffect.Hacking";
}

NotStatusEffectTypeCyberwareMalfunction : StatusEffectTypeCyberwareMalfunction
{
	invert = true;
}

StatusEffectTypeCyberwareMalfunction : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.QuickHackStaggerCyberware";
}

NotStatusEffectCyberwareMalfunctionLvl1 : StatusEffectCyberwareMalfunctionLvl1
{
	invert = true;
}

StatusEffectCyberwareMalfunctionLvl1 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CyberwareMalfunctionLvl1";
}

NotStatusEffectCyberwareMalfunctionLvl2 : StatusEffectCyberwareMalfunctionLvl2
{
	invert = true;
}

StatusEffectCyberwareMalfunctionLvl2 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CyberwareMalfunctionLvl2";
}

NotStatusEffectCyberwareMalfunctionLvl3 : StatusEffectCyberwareMalfunctionLvl3
{
	invert = true;
}

StatusEffectCyberwareMalfunctionLvl3 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CyberwareMalfunctionLvl3";
}

NotStatusEffectCyberwareMalfunctionLvl4 : StatusEffectCyberwareMalfunctionLvl4
{
	invert = true;
}

StatusEffectCyberwareMalfunctionLvl4 : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CyberwareMalfunctionLvl4";
}

NotStatusEffectCyberwareMalfunctionLvl4PlusPlus : StatusEffectCyberwareMalfunctionLvl4PlusPlus
{
	invert = true;
}

StatusEffectCyberwareMalfunctionLvl4PlusPlus : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.CyberwareMalfunctionLvl4PlusPlus";
}

NotStatusEffectDefeatedWithRecover : StatusEffectDefeatedWithRecover
{
	invert = true;
}

StatusEffectDefeatedWithRecover : AIStatusEffectCond
{
	statusEffectType = "BaseStatusEffectTypes.DefeatedWithRecover";
}

NotStatusEffectStrongArmsPhysicalActive : StatusEffectStrongArmsPhysicalActive
{
	invert = true;
}

StatusEffectStrongArmsPhysicalActive : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.StrongArmsPhysicalActive";
}

NotStatusEffectStrongArmsThermalActive : StatusEffectStrongArmsThermalActive
{
	invert = true;
}

StatusEffectStrongArmsThermalActive : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.StrongArmsThermalActive";
}

NotStatusEffectStrongArmsChemicalActive : StatusEffectStrongArmsChemicalActive
{
	invert = true;
}

StatusEffectStrongArmsChemicalActive : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.StrongArmsChemicalActive";
}

NotStatusEffectStrongArmsElecricActive : StatusEffectStrongArmsElecricActive
{
	invert = true;
}

StatusEffectStrongArmsElecricActive : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.StrongArmsElecricActive";
}

StatusEffectStimTargetBeingCarried : AIStatusEffectCond
{
	target = "AIActionTarget.StimTarget";
	statusEffect = "BaseStatusEffect.BeingCarried";
}

StatusEffectStimTargetKill : AIStatusEffectCond
{
	target = "AIActionTarget.StimTarget";
	statusEffectType = "BaseStatusEffectTypes.Kill";
}

StatusEffectStimTargetDefeated : AIStatusEffectCond
{
	target = "AIActionTarget.StimTarget";
	statusEffectType = "BaseStatusEffectTypes.Defeated";
}

NotStatusEffectTagSkipDefeatedStartup : StatusEffectTagSkipDefeatedStartup
{
	invert = true;
}

StatusEffectTagSkipDefeatedStartup : AIStatusEffectCond
{
	gameplayTag = "SkipDefeatedStartup";
}

NotStatusEffectMinotaurRightExplosion : StatusEffectMinotaurRightExplosion
{
	invert = true;
}

StatusEffectMinotaurRightExplosion : AIStatusEffectCond
{
	statusEffect = "Minotaur.RightExplosion";
}

NotStatusEffectMinotaurLeftExplosion : StatusEffectMinotaurLeftExplosion
{
	invert = true;
}

StatusEffectMinotaurLeftExplosion : AIStatusEffectCond
{
	statusEffect = "Minotaur.LeftExplosion";
}

NotStatusEffectNPCForceStagger : StatusEffectNPCForceStagger
{
	invert = true;
}

StatusEffectNPCForceStagger : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.NPCForceStagger";
}

NotStatusEffectNoCover : StatusEffectNoCover
{
	invert = true;
}

StatusEffectNoCover : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.NoCover";
}

NotStatusEffectTagBreathing : StatusEffectTagBreathing
{
	invert = true;
}

StatusEffectTagBreathing : AIStatusEffectCond
{
	target = "AIActionTarget.Player";
	gameplayTag = "Breathing";
}

NotIsInWorkspot : AIWorkspotCond
{
	isInWorkspot = 0;
}

IsInWorkspot : AIWorkspotCond
{
	isInWorkspot = 1;
}

StimTargetWSObject : AIWorkspotCond
{
	workspotObj = "AIActionTarget.StimTarget";
}

NotAttackWithSubActionInAir : AttackWithSubActionInAir
{
	invert = true;
}

AttackWithSubActionInAir : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SubActionInAir"
	];
}

NotPreviousAttackNameBlockDodge : PreviousAttackNameBlockDodge
{
	invert = true;
}

PreviousAttackNameBlockDodge : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"BlockDodge"
	];
}

NotPreviousAttackNameAtkFromSprint : PreviousAttackNameAtkFromSprint
{
	invert = true;
}

PreviousAttackNameAtkFromSprint : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"AtkFromSprint"
	];
}

NotPreviousAttackNameDashForward : PreviousAttackNameDashForward
{
	invert = true;
}

PreviousAttackNameDashForward : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"DashForward"
	];
}

NotPreviousAttackNameDashBack : PreviousAttackNameDashBack
{
	invert = true;
}

PreviousAttackNameDashBack : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"DashBack"
	];
}

NotPreviousAttackNameSwipedUp : PreviousAttackNameSwipedUp
{
	invert = true;
}

PreviousAttackNameSwipedUp : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SwipedUp"
	];
}

NotPreviousAttackNameSwipedDown : PreviousAttackNameSwipedDown
{
	invert = true;
}

PreviousAttackNameSwipedDown : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SwipedDown"
	];
}

NotPreviousAttackNameHammer : PreviousAttackNameHammer
{
	invert = true;
}

PreviousAttackNameHammer : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Hammer"
	];
}

NotPreviousAttackNamePickUpHammer : PreviousAttackNamePickUpHammer
{
	invert = true;
}

PreviousAttackNamePickUpHammer : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"PickUpHammer"
	];
}

NotPreviousAttackNameMove : PreviousAttackNameMove
{
	invert = true;
}

PreviousAttackNameMove : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Move"
	];
}

NotPreviousAttackNameSandevistanStraight : PreviousAttackNameSandevistanStraight
{
	invert = true;
}

PreviousAttackNameSandevistanStraight : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SandevistanStraight"
	];
}

NotPreviousAttackNameSpecialGrabAttack : PreviousAttackNameSpecialGrabAttack
{
	invert = true;
}

PreviousAttackNameSpecialGrabAttack : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SpecialGrabAttack"
	];
}

PreviousAttackNameCloseSingleLeft01MeleeAttackLight01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"CloseSingleLeft01MeleeAttackLight01"
	];
}

PreviousAttackNameCloseSingleRight01MeleeAttackLight01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"CloseSingleRight01MeleeAttackLight01"
	];
}

PreviousAttackNameCloseSingleBack01MeleeAttackLight01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"CloseSingleBack01MeleeAttackLight01"
	];
}

PreviousAttackNameCloseCombo01MeleeAttackLight01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"CloseCombo01MeleeAttackLight01"
	];
}

PreviousAttackNameCloseCombo01MeleeAttackLight02 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"CloseCombo01MeleeAttackLight02"
	];
}

PreviousAttackNameCloseCombo01MeleeAttackLight03 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"CloseCombo01MeleeAttackLight03"
	];
}

PreviousAttackNameCloseCombo02MeleeAttackLight01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"CloseCombo02MeleeAttackLight01"
	];
}

PreviousAttackNameCloseCombo02MeleeAttackLight02 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"CloseCombo02MeleeAttackLight02"
	];
}

PreviousAttackNameCloseCombo02MeleeAttackLight03 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"CloseCombo02MeleeAttackLight03"
	];
}

NotPreviousAttackNameCombo01MeleeAttackLight01 : PreviousAttackNameCombo01MeleeAttackLight01
{
	invert = true;
}

PreviousAttackNameCombo01MeleeAttackLight01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo01MeleeAttackLight01"
	];
}

PreviousAttackNameCombo01MeleeAttackLight02 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo01MeleeAttackLight02"
	];
}

PreviousAttackNameCombo01MeleeAttackLight03 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo01MeleeAttackLight03"
	];
}

PreviousAttackNameCombo01MeleeAttackLight04 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo01MeleeAttackLight04"
	];
}

NotPreviousAttackNameCombo02MeleeAttackLight01 : PreviousAttackNameCombo02MeleeAttackLight01
{
	invert = true;
}

PreviousAttackNameCombo02MeleeAttackLight01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo02MeleeAttackLight01"
	];
}

PreviousAttackNameCombo02MeleeAttackLight02 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo02MeleeAttackLight02"
	];
}

PreviousAttackNameCombo02MeleeAttackLight03 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo02MeleeAttackLight03"
	];
}

PreviousAttackNameCombo02MeleeAttackLight04 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo02MeleeAttackLight04"
	];
}

PreviousAttackNameCombo02MeleeAttackLight05 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo02MeleeAttackLight05"
	];
}

PreviousAttackNameCombo03MeleeAttackLight01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo03MeleeAttackLight01"
	];
}

PreviousAttackNameCombo03MeleeAttackLight02 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo03MeleeAttackLight02"
	];
}

PreviousAttackNameCombo03MeleeAttackLight03 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo03MeleeAttackLight03"
	];
}

PreviousAttackNameCombo03MeleeAttackLight04 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo03MeleeAttackLight04"
	];
}

PreviousAttackNameCombo03MeleeAttackLight05 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"Combo03MeleeAttackLight05"
	];
}

PreviousAttackNameSingleMeleeAttackJump01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackJump01"
	];
}

PreviousAttackNameSingleMeleeAttackStrong01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackStrong01"
	];
}

PreviousAttackNameSingleMeleeAttackStrong02 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackStrong02"
	];
}

PreviousAttackNameSingleMeleeAttackStrong03 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackStrong03"
	];
}

PreviousAttackNameSingleMeleeAttackStrong04 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackStrong04"
	];
}

NotPreviousAttackNameSingleMeleeAttackStrong05 : PreviousAttackNameSingleMeleeAttackStrong05
{
	invert = true;
}

PreviousAttackNameSingleMeleeAttackStrong05 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackStrong05"
	];
}

PreviousAttackNameSingleMeleeAttackStrong06 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackStrong06"
	];
}

PreviousAttackNameSingleMeleeAttackCharge01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackCharge01"
	];
}

PreviousAttackNameSingleMeleeAttackCharge02 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackCharge02"
	];
}

PreviousAttackNameSingleMeleeAttackCharge03 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackCharge03"
	];
}

PreviousAttackNameSingleMeleeAttackChargeJump02 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"SingleMeleeAttackChargeJump02"
	];
}

PreviousAttackNameInfiniteGenericMeleeAttackStartup01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"melee_combo_infinite_startup_01"
	];
}

PreviousAttackNameInfiniteGenericMeleeAttackStartup02 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"InfiniteGenericMeleeAttackStartup02"
	];
}

PreviousAttackNameInfiniteGenericMeleeAttackFromAttack01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"InfiniteGenericMeleeAttackFromAttack01"
	];
}

PreviousAttackNameInfiniteGenericMeleeAttackFromAttack02 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"InfiniteGenericMeleeAttackFromAttack02"
	];
}

PreviousAttackNameInfiniteGenericMeleeAttackFromAttack03 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"InfiniteGenericMeleeAttackFromAttack03"
	];
}

PreviousAttackNameInfiniteGenericMeleeAttackFromAttack04 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"InfiniteGenericMeleeAttackFromAttack04"
	];
}

PreviousAttackNameParryMeleeAttack01 : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"ParryMeleeAttack01"
	];
}

PreviousAttackNameQuickMelee2secTimeWindow : AIPreviousAttackCond
{
	previousAttackName = 
	[
		"QuickMelee"
	];
	timeWindow = 2.f;
}

PreviousAttackNameNone : AIPreviousAttackCond
{
	previousAttackName = 
	[
		""
	];
}

NotPreviousAttackHorizontal : AIActionAND
{
	AND = 
	[
		"Condition.NotPreviousAttackDirectionLeftToRight", "Condition.NotPreviousAttackDirectionRightToLeft"
	];
}

PreviousAttackVertical : AIActionOR
{
	OR = 
	[
		"Condition.PreviousAttackDirectionUpToDown", "Condition.PreviousAttackDirectionCenter", "Condition.PreviousAttackDirectionDownToUp"
	];
}

PreviousAttackVerticalOrDiagonalLeftToRight : AIActionOR
{
	OR = 
	[
		"Condition.PreviousAttackDirectionLeftUpToRightDown", "Condition.PreviousAttackDirectionUpToDown", "Condition.PreviousAttackDirectionCenter", "Condition.PreviousAttackDirectionDownToUp", "Condition.PreviousAttackDirectionRightDownToLeftUp"
	];
}

PreviousAttackVerticalOrDiagonalRightToLeft : AIActionOR
{
	OR = 
	[
		"Condition.PreviousAttackDirectionRightUpToLeftDown", "Condition.PreviousAttackDirectionUpToDown", "Condition.PreviousAttackDirectionCenter", "Condition.PreviousAttackDirectionDownToUp", "Condition.PreviousAttackDirectionLeftDownToRightUp"
	];
}

PreviousAttackDiagonalLeftToRight : AIActionOR
{
	OR = 
	[
		"Condition.PreviousAttackDirectionLeftUpToRightDown", "Condition.PreviousAttackDirectionRightDownToLeftUp"
	];
}

PreviousAttackDiagonalRightToLeft : AIActionOR
{
	OR = 
	[
		"Condition.PreviousAttackDirectionRightUpToLeftDown", "Condition.PreviousAttackDirectionLeftDownToRightUp"
	];
}

NotPreviousAttackDirectionCenter : PreviousAttackDirectionCenter
{
	invert = true;
}

PreviousAttackDirectionCenter : AIPreviousAttackCond
{
	previousAttackDirection = 0;
}

NotPreviousAttackDirectionDownToUp : PreviousAttackDirectionDownToUp
{
	invert = true;
}

PreviousAttackDirectionDownToUp : AIPreviousAttackCond
{
	previousAttackDirection = 1;
}

NotPreviousAttackDirectionLeftDownToRightUp : PreviousAttackDirectionLeftDownToRightUp
{
	invert = true;
}

PreviousAttackDirectionLeftDownToRightUp : AIPreviousAttackCond
{
	previousAttackDirection = 2;
}

NotPreviousAttackDirectionLeftToRight : PreviousAttackDirectionLeftToRight
{
	invert = true;
}

PreviousAttackDirectionLeftToRight : AIPreviousAttackCond
{
	previousAttackDirection = 3;
}

NotPreviousAttackDirectionLeftUpToRightDown : PreviousAttackDirectionLeftUpToRightDown
{
	invert = true;
}

PreviousAttackDirectionLeftUpToRightDown : AIPreviousAttackCond
{
	previousAttackDirection = 4;
}

NotPreviousAttackDirectionRightDownToLeftUp : PreviousAttackDirectionRightDownToLeftUp
{
	invert = true;
}

PreviousAttackDirectionRightDownToLeftUp : AIPreviousAttackCond
{
	previousAttackDirection = 5;
}

NotPreviousAttackDirectionRightToLeft : PreviousAttackDirectionRightToLeft
{
	invert = true;
}

PreviousAttackDirectionRightToLeft : AIPreviousAttackCond
{
	previousAttackDirection = 6;
}

NotPreviousAttackDirectionRightUpToLeftDown : PreviousAttackDirectionRightUpToLeftDown
{
	invert = true;
}

PreviousAttackDirectionRightUpToLeftDown : AIPreviousAttackCond
{
	previousAttackDirection = 7;
}

NotPreviousAttackDirectionUpToDown : PreviousAttackDirectionUpToDown
{
	invert = true;
}

PreviousAttackDirectionUpToDown : AIPreviousAttackCond
{
	previousAttackDirection = 8;
}

TargetStaminaBelow35Perc : AIStatPoolCond
{
	target = "AIActionTarget.CombatTarget";
	statPool = "BaseStatPools.Stamina";
	percentage = ( -1.f, 35.f );
}

TargetStaminaAbove35Perc : AIStatPoolCond
{
	target = "AIActionTarget.CombatTarget";
	statPool = "BaseStatPools.Stamina";
	percentage = ( 35.f, -1.f );
}

TargetStaminaBelow50Perc : AIStatPoolCond
{
	target = "AIActionTarget.CombatTarget";
	statPool = "BaseStatPools.Stamina";
	percentage = ( -1.f, 50.f );
}

StaminaAbove20perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Stamina";
	percentage = ( 20.f, -1.f );
}

StaminaAbove80perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Stamina";
	percentage = ( 80.f, -1.f );
}

StaminaAbove0perc : Stamina0perc
{
	invert = true;
}

Stamina0perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Stamina";
	percentage = ( -1.f, 0.f );
}

HealthAbove5perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 5.f, -1.f );
}

HealthBelow5perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 5.f );
}

HealthAbove15perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 15.f, -1.f );
}

HealthBelow15perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 15.f );
}

HealthAbove25perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 25.f, -1.f );
}

HealthBelow25perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 25.f );
}

HealthAbove50perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 50.f, -1.f );
}

HealthBelow50perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 50.f );
}

HealthAbove60perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 60.f, -1.f );
}

HealthBelow60perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 60.f );
}

HealthAbove65perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 65.f, -1.f );
}

HealthBelow65perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 65.f );
}

HealthAbove75perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 75.f, -1.f );
}

HealthBelow75perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 75.f );
}

HealthAbove85perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 85.f, -1.f );
}

HealthBelow85perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 85.f );
}

HealthBelow70perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 70.f );
}

HealthBelow100perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 100.f );
}

HealthBelow95perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 95.f );
}

HealthBelow90perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 90.f );
}

HealthBelow30perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 30.f );
}

HealthAbove30perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 30.f, -1.f );
}

HealthBelow10perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 10.f );
}

HealthAbove10perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 10.f, -1.f );
}

HealthAbove1perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( 1.f, -1.f );
}

HealthBelow1perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 1.f );
}

HealthAbove0perc : Health0perc
{
	invert = true;
}

Health0perc : AIStatPoolCond
{
	statPool = "BaseStatPools.Health";
	percentage = ( -1.f, 0.f );
}

TargetHealthAbove32Perc : AIStatPoolCond
{
	target = "AIActionTarget.CombatTarget";
	statPool = "BaseStatPools.Health";
	percentage = ( 32.f, -1.f );
}

TargetHealthAbove50Perc : AIStatPoolCond
{
	target = "AIActionTarget.CombatTarget";
	statPool = "BaseStatPools.Health";
	percentage = ( 50.f, -1.f );
}

ReprimandEscalationMaxValue : AIStatPoolCond
{
	statPool = "BaseStatPools.ReprimandEscalation";
	percentage = ( 100.f, -1.f );
}

ReprimandEscalationMinValue : AIStatPoolCond
{
	statPool = "BaseStatPools.ReprimandEscalation";
	percentage = ( -1.f, 0.f );
}

NotCallReinforcementProgress100perc : CallReinforcementProgress100perc
{
	invert = true;
}

CallReinforcementProgress100perc : AIStatPoolCond
{
	statPool = "BaseStatPools.CallReinforcementProgress";
	percentage = ( 100.f, 0.f );
}

NotCallReinforcementProgressIncreasing : CallReinforcementProgressIncreasing
{
	invert = true;
}

CallReinforcementProgressIncreasing : AIStatPoolCond
{
	statPool = "BaseStatPools.CallReinforcementProgress";
	isIncreasing = 1;
}

MinBlockCount1 : AIBlockCountCond
{
	minBlockCount = 1;
}

MinMAxBlockCount2 : AIBlockCountCond
{
	minBlockCount = 2;
	maxBlockCount = 2;
}

MinBlockCount2 : AIBlockCountCond
{
	minBlockCount = 2;
}

MaxBlockCount2 : AIBlockCountCond
{
	maxBlockCount = 2;
}

MinMaxBlockCount4 : AIBlockCountCond
{
	minBlockCount = 4;
	maxBlockCount = 4;
}

MinBlockCount4 : AIBlockCountCond
{
	minBlockCount = 4;
}

MaxBlockCount4 : AIBlockCountCond
{
	maxBlockCount = 4;
}

AttackOwnerMaxParriesCount1 : AIBlockCountCond
{
	ownerAttackParriedCount = 1;
}

AttackOwnerMaxParriesCount2 : AIBlockCountCond
{
	ownerAttackParriedCount = 2;
}

AttackOwnerMaxParriesCount3 : AIBlockCountCond
{
	ownerAttackParriedCount = 3;
}

NotAndroid : Android
{
	invert = true;
}

Android : AINPCTypeCond
{
	allowedNPCTypes = 
	[
		"NPCType.Android"
	];
}

NotHuman : Human
{
	invert = true;
}

Human : AINPCTypeCond
{
	allowedNPCTypes = 
	[
		"NPCType.Human"
	];
}

NotDrone : Drone
{
	invert = true;
}

Drone : AINPCTypeCond
{
	allowedNPCTypes = 
	[
		"NPCType.Drone"
	];
}

NotMech : Mech
{
	invert = true;
}

Mech : AINPCTypeCond
{
	allowedNPCTypes = 
	[
		"NPCType.Mech"
	];
}

TargetNotPlayerFollower : TargetIsPlayerFollower
{
	invert = true;
}

TargetIsPlayerFollower : AINPCTypeCond
{
	target = "AIActionTarget.CombatTarget";
	isFollower = 1;
	allowedNPCTypes = 
	[
		"NPCType.AAny"
	];
}

TargetIsPlayer : NotTargetIsPlayer
{
	invert = true;
}

NotTargetIsPlayer : AINPCTypeCond
{
	target = "AIActionTarget.CombatTarget";
	allowedNPCTypes = 
	[
		"NPCType.AAny"
	];
}

NotCurrentNetrunnerProxyDeviceIsActive : AINPCTypeCond
{
	target = "AIActionTarget.CurrentNetrunnerProxy";
	deviceState = 0;
}

NotHighClass : HighClass
{
	invert = true;
}

HighClass : AINPCTypeCond
{
	visualTags = 
	[
		"RichCasual", "HighClass", "HighCorpo"
	];
}

NCPD : AINPCTypeCond
{
	visualTags = 
	[
		"NCPD", "Police"
	];
}

Cerberus : AINPCTypeCond
{
	allowedNPCTypes = 
	[
		"NPCType.Cerberus"
	];
}

NotManMassive : ManMassive
{
	invert = true;
}

ManMassive : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsManMassive"
	];
}

NotManBig : ManBig
{
	invert = true;
}

ManBig : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsManBig"
	];
}

CloseToAvoidPos : AILoSPositionCond
{
	maxRadiusXY = 0.3f;
	type = 2;
}

NotRightArmLookAtActive : RightArmLookAtActive
{
	invert = true;
}

RightArmLookAtActive : AILookAtCond
{
	rightArmLookAtActive = 2;
}

RightArmLookAtOff : AILookAtCond
{
	rightArmLookAtActive = 0;
}

NotInMaxTacAV : InMaxTacAV
{
	invert = true;
}

InMaxTacAV : AIVehicleCond
{
	hasTags = 
	[
		"Av", "MaxTac"
	];
}

NotInVehicle : AIVehicleCond
{
	invert = true;
}

InVehicle : AIVehicleCond
{
}

CanShootInCarChase : AICanShootInCarChaseCond
{
}

CannotShootInCarChase : AICanShootInCarChaseCond
{
	invert = true;
}

AssignedVehicle : AIVehicleCond
{
	vehicle = "AIActionTarget.AssignedVehicle";
}

NotTargetInVehicle : TargetInVehicle
{
	invert = true;
}

TargetInVehicle : AIVehicleCond
{
	vehicle = "AIActionTarget.CombatTarget";
}

NotCombatTargetVehicleMoving : AIVehicleCond
{
	vehicle = "AIActionTarget.CombatTarget";
	currentSpeed = ( -1.f, 3.f );
}

NotVehicleMoving : AIVehicleCond
{
	currentSpeed = ( -1.f, 0.5f );
}

NotIsPlayerOnNavmesh : IsPlayerOnNavmesh
{
	invert = true;
}

IsPlayerOnNavmesh : AIIsOnNavmeshCond
{
	target = "AIActionTarget.Player";
	radius = 0.1f;
}

IsStimTargetOnNavmesh : AIIsOnNavmeshCond
{
	target = "AIActionTarget.StimTarget";
	radius = 1.f;
}

IsFollowerOnNavmesh : AIIsOnNavmeshCond
{
	target = "AIActionTarget.FriendlyTarget";
	radius = 1.f;
}

NotFollowerInVehicle : FollowerInVehicle
{
	invert = true;
}

FollowerInVehicle : AIVehicleCond
{
	vehicle = "AIActionTarget.FriendlyTarget";
}

NotOnMotorcycle : OnMotorcycle
{
	invert = true;
}

OnMotorcycle : AIVehicleCond
{
	hasTags = 
	[
		"Motorcycle"
	];
}

NotInSportVehicle : InSportVehicle
{
	invert = true;
}

InSportVehicle : AIVehicleCond
{
	hasTags = 
	[
		"Sport"
	];
}

VehicleHasTagsFastReaction : AIVehicleCond
{
	hasTags = 
	[
		"FastReaction"
	];
}

NotDriverInStimVehicle : AIVehicleCond
{
	driverCheck = 0;
	vehicle = "AIActionTarget.StimTarget";
}

DriverInStimVehicle : AIVehicleCond
{
	vehicle = "AIActionTarget.StimTarget";
	driverCheck = 1;
}

NotDriverInAssignedVehicle : AIVehicleCond
{
	driverCheck = 0;
	vehicle = "AIActionTarget.AssignedVehicle";
}

DriverInAssignedVehicle : AIVehicleCond
{
	vehicle = "AIActionTarget.AssignedVehicle";
	driverCheck = 1;
}

StimTargetNotInVehicle : StimTargetInVehicle
{
	invert = true;
}

StimTargetInVehicle : AIVehicleCond
{
	vehicle = "AIActionTarget.StimTarget";
}

FollowerDrivingVehicle : AIVehicleCond
{
	vehicle = "AIActionTarget.FriendlyTarget";
	driverCheck = 1;
	freeSlots = 
	[
		"Vehicle.SeatFrontRight"
	];
}

NotDriver : AIDriverCond
{
	invert = true;
}

Driver : AIDriverCond
{
}

AssignedVehiclePerformedChase : AIEverPerformedChase
{
}

AssignedVehicleNeverPerformedChase : AssignedVehiclePerformedChase
{
	invert = true;
}

TargetMovingInCircles : AIMovingInCirclesCond
{
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
	range = 10.0f;
	time = 15.0f;
}

NotTargetMovingInCircles : TargetMovingInCircles
{
	invert = true;
}

TargetStandingOnTopOfMovingVehicle : AITargetStandingOnTopOfMovingVehicleCond
{
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
}

NotTargetStandingOnTopOfMovingVehicle : TargetStandingOnTopOfMovingVehicle
{
	invert = true;
}

TargetInUnmountingRange : AITargetInUnmountingRangeCond
{
}

NotTargetInUnmountingRange : TargetInUnmountingRange
{
	invert = true;
}

AssignedVehicleCanReachTarget : AIAssignedVehicleCanReachTargetCond
{
	fk< AIActionTarget > target = "AIActionTarget.CombatTarget";
}

AssignedVehicleCannotReachTarget : AssignedVehicleCanReachTarget
{
	invert = true;
	duration = 2.8f;
}

AssignedVehicleInPanicDriving : AIAssignedVehicleInPanicDriving
{
}

AssignedVehicleNotInPanicDriving : AIAssignedVehicleInPanicDriving
{
	invert = true;
}

AssignedVehicleInRace : AIAssignedVehicleInRace
{
}

AssignedVehicleNotInRace : AIAssignedVehicleInRace
{
	invert = true;
}

ThrowCond : AIThrowCond
{
	target = "AIActionTarget.CombatTarget";
	clearLOSDistanceTolerance = 3.f;
}

WeaponLockedOnTarget : AIActionOR
{
	OR = 
	[
		{
			weaponSlot = "AttachmentSlots.WeaponRight";
		} : AIWeaponLockedOnTargetCond, 
		{
			weaponSlot = "AttachmentSlots.WeaponLeft";
		} : AIWeaponLockedOnTargetCond
	];
}

NotIsInCameraFrustrum : AIIsInActiveCameraCond
{
	invert = true;
}

IsInCameraFrustrum : AIIsInActiveCameraCond
{
}

NotIsTargetInCameraFrustrum : IsTargetInCameraFrustrum
{
	invert = true;
}

IsTargetInCameraFrustrum : AIIsInActiveCameraCond
{
	target = "AIActionTarget.CombatTarget";
}

NotIsSelectedCoverInCameraFrustrum0dot1mRadius : IsSelectedCoverInCameraFrustrum0dot1mRadius
{
	invert = true;
}

IsSelectedCoverInCameraFrustrum0dot1mRadius : AIIsInActiveCameraCond
{
	radius = 0.1f;
	target = "AIActionTarget.SelectedCover";
}

MaxDodgeCount1 : AIDodgeCountCond
{
	maxDodgeCount = 1;
}

MaxDodgeCount2 : AIDodgeCountCond
{
	maxDodgeCount = 2;
}

MaxDodgeCount3 : AIDodgeCountCond
{
	maxDodgeCount = 3;
}

MaxDodgeCount4 : AIDodgeCountCond
{
	maxDodgeCount = 4;
}

MaxDodgeCount5 : AIDodgeCountCond
{
	maxDodgeCount = 5;
}

NotCanThrowAtTarget : CanThrowAtTarget
{
	invert = true;
}

CanThrowAtTarget : AIThrowCond
{
	target = "AIActionTarget.CombatTarget";
	weaponSlot = "AttachmentSlots.WeaponRight";
}

NotHasJuiceDispenserBackWeakspot : HasJuiceDispenserBackWeakspot
{
	invert = true;
}

HasJuiceDispenserBackWeakspot : AIWeakSpotCond
{
	weakspot = "Weakspots.Juice_Dispenser_Back_Weakspot";
}

NotHasMechWeaponRightWeakspot : HasMechWeaponRightWeakspot
{
	invert = true;
}

HasMechWeaponRightWeakspot : AIWeakSpotCond
{
	weakspot = "Weakspots.Mech_Weapon_Right_Weakspot";
}

NotHasMechWeaponLeftWeakspot : HasMechWeaponLeftWeakspot
{
	invert = true;
}

HasMechWeaponLeftWeakspot : AIWeakSpotCond
{
	weakspot = "Weakspots.Mech_Weapon_Left_Weakspot";
}

NotHasExoWeakspot : HasExoWeakspot
{
	invert = true;
}

HasExoWeakspot : AIWeakSpotCond
{
	weakspot = "Weakspots.Exo_Weakspot";
}

SpreadIncreaseAngle30deg : AIExtendTargetCirclingCond
{
	spreadIncreaseAngle = 30.f;
}

IsFriendMoving : AIVelocityCond
{
	target = "AIActionTarget.FriendlyTarget";
	range = ( 0.25f, -1.0f );
	timePeriod = 1.0f;
}

FriendHeadingToOwnerDotProduct : AIVelocityDotCond
{
	positionTarget = "AIActionTarget.Owner";
	velocityTarget = "AIActionTarget.FriendlyTarget";
	dotRange = ( 0.25f, 1.f );
	timePeriod = 1.f;
}

NotTargetHeadingToOwnerDotProduct : TargetHeadingToOwnerDotProduct
{
	invert = true;
}

TargetHeadingToOwnerDotProduct : AIVelocityDotCond
{
	positionTarget = "AIActionTarget.Owner";
	velocityTarget = "AIActionTarget.CombatTarget";
	dotRange = ( 0.25f, 1.f );
	timePeriod = 1.f;
}

NotTargetHeadingInOppositeDirectionToOwnerDotProduct : TargetHeadingInOppositeDirectionToOwnerDotProduct
{
	invert = true;
}

TargetHeadingInOppositeDirectionToOwnerDotProduct : AIVelocityDotCond
{
	positionTarget = "AIActionTarget.Owner";
	velocityTarget = "AIActionTarget.CombatTarget";
	dotRange = ( -1.f, -0.25f );
	timePeriod = 1.f;
}

FriendMovingInOppositeDirectionDotProduct : AIVelocitiesDotCond
{
	firstTarget = "AIActionTarget.Owner";
	secondTarget = "AIActionTarget.FriendlyTarget";
	firstTimePeriod = 1.f;
	secondTimePeriod = 1.f;
	dotRange = ( -1.f, -0.25f );
}

NotTargetMovingInOppositeDirectionDotProduct : TargetMovingInOppositeDirectionDotProduct
{
	invert = true;
}

TargetMovingInOppositeDirectionDotProduct : AIVelocitiesDotCond
{
	firstTarget = "AIActionTarget.Owner";
	secondTarget = "AIActionTarget.CombatTarget";
	firstTimePeriod = 1.f;
	secondTimePeriod = 1.f;
	dotRange = ( -1.f, -0.25f );
}

IsFromDynamicSpawnSystem : AIIsFromDynamicSpawnSystem
{
}

IsNotDynamicSpawnSystem : AIIsFromDynamicSpawnSystem
{
	invert = true;
}

IsFromPreventionSystem : AIIsFromPreventionSystem
{
}

IsNotFromPreventionSystem : AIIsFromPreventionSystem
{
	invert = true;
}

IsHeatStage5Active : AIIsHeatStage5Active
{
}

IsNotHeatStage5Active : AIIsHeatStage5Active
{
	invert = true;
}

TargetInPreventionFreeArea : AITargetInPreventionFreeArea
{
}

TargetNotInPreventionFreeArea : AITargetInPreventionFreeArea
{
	invert = true;
}

AssignedVehicleInInnerAreaSpeedLimiter : AIVehicleInsideInnerAreaOfAreaSpeedLimiter
{
	vehicle = "AIActionTarget.AssignedVehicle";
}

AssignedVehicleNotInInnerAreaSpeedLimiter : AIVehicleInsideInnerAreaOfAreaSpeedLimiter
{
	vehicle = "AIActionTarget.AssignedVehicle";
	invert = true;
}

IsBlockedFromShooting : AIIsShootingBlockedFromPrevention
{
}

IsNotBlockedFromShooting : AIIsShootingBlockedFromPrevention
{
	invert = true;
}

NotIsStoryGameDifficulty : IsStoryGameDifficulty
{
	invert = true;
}

IsStoryGameDifficulty : AIGameDifficultyCond
{
	comparedDifficulty = 1;
	comparisonType = "Equal";
}

IsEasyGameDifficulty : AIGameDifficultyCond
{
	comparedDifficulty = 2;
	comparisonType = "LessOrEqual";
}

IsExactlyEasyGameDifficulty : AIGameDifficultyCond
{
	comparedDifficulty = 2;
	comparisonType = "Equal";
}

IsHardGameDifficulty : AIGameDifficultyCond
{
	comparedDifficulty = 3;
	comparisonType = "MoreOrEqual";
}

IsExactlyHardGameDifficulty : AIGameDifficultyCond
{
	comparedDifficulty = 3;
	comparisonType = "Equal";
}

NotIsImpossibleGameDifficulty : IsImpossibleGameDifficulty
{
	invert = true;
}

IsImpossibleGameDifficulty : AIGameDifficultyCond
{
	comparedDifficulty = 4;
	comparisonType = "Equal";
}

IsTrashNPCDifficulty : AINPCDifficultyCond
{
	comparedDifficulty = 1;
	comparisonType = "Equal";
}

IsEasyNPCDifficulty : AINPCDifficultyCond
{
	comparedDifficulty = 2;
	comparisonType = "Equal";
}

IsNormalNPCDifficulty : AINPCDifficultyCond
{
	comparedDifficulty = 3;
	comparisonType = "Equal";
}

IsHardNPCDifficulty : AINPCDifficultyCond
{
	comparedDifficulty = 4;
	comparisonType = "MoreOrEqual";
}

IsImpossibleNPCDifficulty : AINPCDifficultyCond
{
	comparedDifficulty = 5;
	comparisonType = "Equal";
}

NotIsBossNPCRarity : IsBossNPCRarity
{
	invert = true;
}

IsBossNPCRarity : AINPCRarityCond
{
	rarity = "Boss";
}

NotIsMaxTacNPCRarity : IsMaxTacNPCRarity
{
	invert = true;
}

IsMaxTacNPCRarity : AINPCRarityCond
{
	rarity = "MaxTac";
}

NotIsExoNPCRarity : IsExoNPCRarity
{
	invert = true;
}

IsExoNPCRarity : AINPCRarityCond
{
	rarity = "Exo";
}

IsEliteNPCRarity : AINPCRarityCond
{
	rarity = "Elite";
}

IsNormalNPCRarity : AINPCRarityCond
{
	rarity = "Normal";
}

IsOfficerNPCRarity : AINPCRarityCond
{
	rarity = "Officer";
}

IsRareNPCRarity : AINPCRarityCond
{
	rarity = "Rare";
}

IsTrashNPCRarity : AINPCRarityCond
{
	rarity = "Trash";
}

IsWeakNPCRarity : AINPCRarityCond
{
	rarity = "Weak";
}

NotNetrunnerProxyIsBossNPCRarity : NetrunnerProxyIsBossNPCRarity
{
	invert = true;
}

NetrunnerProxyIsBossNPCRarity : AINPCRarityCond
{
	rarity = "Boss";
	target = "AIActionTarget.NetrunnerProxy";
}

NetrunnerProxyIsMaxTacNPCRarity : AINPCRarityCond
{
	rarity = "MaxTac";
	target = "AIActionTarget.NetrunnerProxy";
}

NotCurrentNetrunnerProxyIsBossNPCRarity : CurrentNetrunnerProxyIsBossNPCRarity
{
	invert = true;
}

CurrentNetrunnerProxyIsBossNPCRarity : AINPCRarityCond
{
	rarity = "Boss";
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

CurrentNetrunnerProxyIsMaxTacNPCRarity : AINPCRarityCond
{
	rarity = "MaxTac";
	target = "AIActionTarget.CurrentNetrunnerProxy";
}

StatusEffectAnyEmpReed : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.EMPReed";
}

NotStatusEffectAnyEmpReed : StatusEffectAnyEmpReed
{
	invert = true;
}

NotIsNPCEmpReed : AIActionAND
{
	AND = 
	[
		"Condition.NotStatusEffectAnyEmpReed"
	];
}

InArmedVehicle : AIInArmedVehicleCond
{
}

StatusEffectPreventQHStaggerAnimation : AIStatusEffectCond
{
	statusEffect = "BaseStatusEffect.PreventQHStaggerAnimation";
}

NotStatusEffectPreventQHStaggerAnimation : StatusEffectPreventQHStaggerAnimation
{
	invert = true;
}

AbilityCanRetreat : AIAbilityCond
{
	abilities = 
	[
		"Ability.CanRetreat"
	];
}

HackSelectorCondition_VeryAggressive : AIActionAND
{
	AND = 
	[
		"Condition.CombatTarget", "Condition.NotIsUsingOffMeshLink", "Condition.NotIsMoving", "Condition.NotInRegularCover", "Condition.TargetIsPlayer", "Condition.TargetNotPlayerFollower", "Condition.NotPlayerBeingHacked", {
			OR = 
			[
				{
					AND = 
					[
						"Condition.TargetBelow50m", "Condition.NetrunnerProxy"
					];
				} : AIActionAND
			];
		} : AIActionOR, 
		{
			invert = true;
			AND = 
			[
				"Condition.AbilityCanUseCovers", "Condition.IsCoverSelected", "Condition.NotTicketCharge"
			];
		} : AIActionAND
	];
}

CoverHackSelectorCondition_VeryAggresive : AIActionAND
{
	AND = 
	[
		"Condition.CombatTarget", "Condition.InCover", "Condition.TargetIsPlayer", "Condition.NotPlayerBeingHacked", {
			OR = 
			[
				{
					AND = 
					[
						"Condition.TargetBelow50m", "Condition.NetrunnerProxy"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow30m", "Condition.TargetIsVisible"
					];
				} : AIActionAND, 
				{
					AND = 
					[
						"Condition.TargetBelow30m", "Condition.NotFurthestSquadmate", "Condition.MinAccuracyValue0dot95"
					];
				} : AIActionAND
			];
		} : AIActionOR
	];
}

Succeed75PercentOfTimes : AIPercentageChanceCond
{
	successProbability = 75;
}

Succeed50PercentOfTimes : AIPercentageChanceCond
{
	successProbability = 50;
}

Succeed25PercentOfTimes : AIPercentageChanceCond
{
	successProbability = 25;
}

Succeed15PercentOfTimes : AIPercentageChanceCond
{
	successProbability = 15;
}

AbilityIsExcludedFromExtraHealingOnHigherDifficulties : AIAbilityCond
{
	abilities = 
	[
		"Ability.IsExcludedFromExtraHealingOnHigherDifficulties"
	];
}

NotAbilityIsExcludedFromExtraHealingOnHigherDifficulties : AbilityIsExcludedFromExtraHealingOnHigherDifficulties
{
	invert = true;
}

